## 第1章 课程介绍

### 1-1 整体介绍

课程定位

帮助大家梳理知识点

讲述面试过程中的要点(技术和非技术)

面试官关注的侧重点

适合人群

* 已经是测试工程师
* 掌握Python基础

课程收获

* 经验丰富的测试人员可梳理知识体系
* 部分知识点你没有接触过可指明学习路线
* 非技术面试过程中可掌握面试侧重点

遇到课程中不包含的面试题怎么办?

其他服务



## 第2章 一线互联网公司的面试流程和技巧

### 2-1 岗位JD分析

测试工程师的岗位要求

岗位JD分析

分层自动化测试经验

瀑布流的布局: 是用时间滚轮,用滚动条来控制

隐藏元素, 

### 2-2 高级、资深测试工程师岗位技能树

开发语言: Python等

数据库: MySQL

操作系统: Linux

网络协议: 

测试技能: 自动化(UI、接口)、性能

业务技能:



### 2-3 测试架构师的能力要求

架构师与工程师等核心区别

* 架构的意义是什么?
  * 不同阶段用最小的代价解决不同问题的能力

### 2-4 测试人员的职业规划-分岔路的选择

初级-> 中级 -> 高级 -> 资深/经理 - > 架构/总监 - > CTO/VP

善于汇报么

未来半年要做什么



### 2-5 一面面试考察的重点

面试类型的分类

* 技术面试
* 项目面试
* 综合素质面试

一面-技术面试的考察重点

T字型人才

* 广博的技术面

目前在我们国内并不需要你技术创新, 虽然这些框架是基于, 你需要的只是学习和了解, 就是你会很多很多框架, 然后不管是数据库也好, 测试技术之类的. 剩下的对业务层面也吃的很透. 

* 专精的技术方向

就是我们列举的测试技术, 运维工程师. , 就要做到最专业, 你的专业, 包括和你合作过的所有合作伙伴. 把它做深、, 围绕一个一个技术项. 你的自动化是怎么做的. 你的性能测试是怎么做的, 那你测试过程中都遇到过什么问题吗? 这个问题, 问题回答浅了. 只有回答, 就是那些技术细节. 然后再着重, 那些你遇到的技术问题, 然后你有可能忽略的技术点.

完全都是技术.

### 2-6 二面面试考察的重点

核心考察点: 价值

* 为团队做了什么(质量/效率层面)
  * 你都为团队做了什么, 你们测试团队的, 有一部分公司, 测试团队, 我们在这里面做的时候, 你就要思考你为整个测试团队都做过什么, 质量层面, 另一方面是效率层面,
* 为项目做了什么
  * 项目提效的话并不是, 你的思维放在整个链路上, 项目好走, 你有没有推进项目周期的, 
* 为公司做了什么
  * 

这三项就是我总结出来的价值, 你作为一个, 你同工不同酬, 多多体现数字方面的东西

持续集成这个事比较好量化, 都是手工部署, 一个项目当中, 

第一是我做了什么, 然后是效率层面, 你跟别人有什么不同, 我为什么要录取你.

### 2-7 三面面试考察重点

能力

* 团队协作能力
* 团队管理能力
* 核心竞争力

### 2-8 面试的重点-精彩的自我介绍

面试官在面试旺季的时候, 要面试很多人, 很多公司有很多, 面试官要给面试, 如何在众多

* 深刻的第一印象

  

* 优秀的语言表达能力

  归纳总结能力, 与众不同的自我介绍, 套用场景的名字, 跟名人挂上钩, 这个人的名字才能接住. 我曾经做过哪些项目, 尽量引导面试官, 怎么去讲面试官, 你不要跟着面试官的思路走.

* 亲和力

  如果表现出行为的话就是微笑. 要具有很具有亲和力, 看到你就喜欢你, 看到你就

  这个问题不会, 这个问题我之前没有遇到过, 但是我可以结合, 万一我有没有, 还请多多指教. 

  当作对自己的历练, 为公司做过的一些贡献, 你可以走出公司的时候, 也是我们自己高素质的一个体现, 也是面试中的重中之重. 

精彩的自我介绍可以想想怎么介绍自己.

## 第3章 一面-Python高级编程和算法面试

### 3-1 Python 高级编程面试真题及考点分析

讲一些比较具有Python风格的, 跟别的语言写法不太一样的这些面试题.

1. 下面的代码打印结果是什么?

    ```python
    a = ('a', 'b', 'c')
    c = copy.copy(a)
    d = copy.deepcopy(a)
    if c == d:
        print("c和d值相等")
    if id(c) == id(d):
        print("c和d地址相等")
    ```
    
    考点:
    
    1. 深浅拷贝
    2. 可变对象和不可变对象
    
    这道题的变形: 第一行是一个小括号, 也可以换成中括号或大括号. 

2. 下面的代码的打印结果是什么

    ```python
    class Person:
        x = 5
        y = 6
        def __init__(self, x, y):
            self.x = x
            self.y = y    
        def add(self):
            return self.x + self.y

    person = Person(10, 20)
    person.z = 7
    print(person.x)
    print(person.y)
    print(Person.x)
    print(Person.y)
    print(Person.add(Person))  # 如果在add方法里不传Person能否检查出来这是错的
    print(person.add())
    print(person.z)
    print(Person.z)
    ```
    
    这道题的考点:
    
    1. 打印过程中是不是报错
    2. 类变量和实例变量的区别,调用方式是什么, 类Person中的x和y与构造函数中的`self.x`和`self.y`是一回事么
    
3. Python中一个函数function接收三个参数`a`, `*args`, `**kwargs`, 他们分别是什么类型

    考点:

    ​		可变参数类型, 关键字参数类型

4. 请根据列表`list1 = [1, 2, 3, 4, 5, 6]`, 使用一行代码生成一个新的列表`list2`, `list2`中每个元素是`list1`中的平方

   考点:

   ​		推导式

5. 请将下面列表进行排序`list1 = [20, 15, 88, 97, 76, 13, 27, 49]`

   考点: 

   ​		排序算法, 排序算法都会考, 只是看用什么方式实现, 区别在效率上

6. 请实现: `@runtime` 效果为当调用`student_run`时会自动打印当前时间

    ```python
    @runtime
    def student_run(name):
        print("student" + name + "run")

    student_run("张三")
    ```
    
    考点: 这里面并没有写调用时间, 调用时间, 直接打出来, 它要求除了这个之外,并打印当前时间. 如果写过 java
    
    会见过注解, 在 Python 中也叫语法糖. 在函数之上加上另外一种功能, 如果没有写过语法糖或注解, 把注解实现的过程的实现原理. 类方法, 静态方法也是在方法上加 @ , @classmethod, @static
    
7. 请简述`func1`和`func2`函数的返回值, 以及函数运行机制

    ```python
    def func1():
        for i in range(1, 5):
            return i

    def func2():
        for i in range(1, 5):
            yield i
    ```
    
    区别在于每个函数的返回值
    
    考点: `return`和`yield`的区别, 尤其在封装框架的过程中

都是 Python 高级编程的, 还会问到其他问题, 这几道问题是比较典型的.

### 3-2 Python面试题

1. Python中的多线程和多进程有什么区别?
2. Python中什么是可变数据类型, 什么是不可变数据类型
3. Python中如何实现单例设计模式
4. Python中一行代码如何实现两数交换
5. Python中的`__new_`和`__init__`两个方法有什么区别

### 3-3 对象的深浅拷贝面试题

创建 `copy_and_deepcopy.py`, 具体深浅拷贝需要导入 `copy` 这个模块. 首先有两个list, `a1` 和 `a2`

```python
import copy

a1 = ['s1', 's2', 's3']
a = [1, 2, a1]
```

然后看一下我们经常在代码里进行的赋值操作, 有赋值、浅拷贝和深拷贝:

```python
# 带着讲一下赋值
b = a
# 浅拷贝
c = copy.copy(a)
# 深拷贝
d = copy.deepcopy(a)
```

如何来观察深浅拷贝的共同点和不同点? 首先来进行值打印, 再来进行一个地址上的观察:

```python
print("值打印")
print(a1)
print(a)
print(b)
print(c)
print(d)
print("地址打印")
print(id(a1))
print(id(a))
print(id(b))
print(id(c))
print(id(d))
```

在内存上是否重新开辟一块内存空间, 才能说明他们到底是不是一个对象; 如果地址相同, 就说明是同一个对象, 如果地址不同就说明是不同的对象.

> 这里面还要说一下可变数据类型和不可变数据类型:
>
> ​	可变数据类型: list, set, dict
>
> ​	不可变数据类型: tuple, str, number

「浅」的意思就是在最上层, 「深」就是说无论有多少层, 就只深挖一下. 运行上面的代码, 打印结果为:

```python
值打印
['s1', 's2', 's3']
[1, 2, ['s1', 's2', 's3']]
[1, 2, ['s1', 's2', 's3']]
[1, 2, ['s1', 's2', 's3']]
[1, 2, ['s1', 's2', 's3']]
地址打印
140393036093632
140393036064640
140393036064640
140393035675200
140393036093792
```

a和b的地址完全相同, 只不过是重新有一个指针, 都是同一个地址.

这里看到深浅拷贝貌似没有区别, 因为深浅拷贝都是重新开辟了一块内存地址, 接下来证明他们的区别:

```python
a1.append("s4")

# 给a1添加一个元素 s4 之后再进行值和地址的打印
print("值打印")
print(a1)
print(a)
print(b)
print(c)
print(d)
print("地址打印")
print(id(a1))
print(id(a))
print(id(b))
print(id(c))
print(id(d))
```

打印结果为:

```python
值打印
['s1', 's2', 's3', 's4']
[1, 2, ['s1', 's2', 's3', 's4']]
[1, 2, ['s1', 's2', 's3', 's4']]
[1, 2, ['s1', 's2', 's3', 's4']]
[1, 2, ['s1', 's2', 's3']]
地址打印
140487888181520
140487888152528
140487888152528
140487887763088
140487888181680
```

`a`和`b`没得说, 浅拷贝`c`的值也跟着产生变化了, 深拷贝`d`的值并没有发生变化. 

再看一下深浅拷贝的概念:

浅拷贝

深拷贝的时候, 无论数据类型有多深, 也就是无论包含多少数据结构在里面, 都会完完整整的复制出来一份, 在里面的数据结构都会完完整整, 但是对浅拷贝有影响, 浅拷贝

浅拷贝

浅拷贝是只拷贝上面一层, , a1 连带着浅拷贝的值也发生变化了, 这就是关于深浅拷贝的区别. 它的值, 浅拷贝是只服之

深就是无论多深, 浅拷贝是只复制外层的

证明深浅拷贝有区别. 

再把 `a` 换成不可变数据类型:

```python
import copy

a1 = ['s1', 's2', 's3']
a = (1, 2, a1)
```

观察所有两次的打印结果:

```python
值打印
['s1', 's2', 's3']
(1, 2, ['s1', 's2', 's3'])
(1, 2, ['s1', 's2', 's3'])
(1, 2, ['s1', 's2', 's3'])
(1, 2, ['s1', 's2', 's3'])
地址打印
140541222951104
140541220988320
140541220988320
140541220988320
140541223040176
修改a1后的值打印
['s1', 's2', 's3', 's4']
(1, 2, ['s1', 's2', 's3', 's4'])
(1, 2, ['s1', 's2', 's3', 's4'])
(1, 2, ['s1', 's2', 's3', 's4'])
(1, 2, ['s1', 's2', 's3'])
修改a1后的地址打印
140541222951104
140541220988320
140541220988320
140541220988320
140541223040176
```

首先地址上面和下面都是一样的. 地址上来说, abc都是一样的, 也就是浅拷贝、赋值的操作都是 只是拿了一个变量, 只有深拷贝才是真正开辟一个内存空间, 这就是深浅拷贝在不可变对象上的, 

综上, 深浅拷贝到底有什么样的区别.

回答这条面试题,可以从两种数据类型上, 在可变数据类型和不可变数据类型的表现.

### 3-4 类变量、实例变量、类对象、实例对象的区别

创建`class_and_instance_var.py`

```python
class Person: # 类对象
    def __init__(self, x, y):
        self.x = x
        self.y = y
        print("x = " + str(x))
		print("y = " + str(y))
        
    def add(self):
        return self.x + self.y

# 实例对象
p = Person(1, 2)
p1 = Person(3, 4)

# 用类和实例进行方法的调用
print(Person.add())  # 产生一个报错: Error:add() missing 1 required positional argument: 'self'
print(p.add())

```

Person代表人类, 不断生产人. 生产出一个人叫p. 

用类来调用实例方法的时候:

```python
print(Person.add())
```

会报错:

```python
Error:add() missing 1 required positional argument: 'self'
```

在self的位置上传入Person:

```python
print(Person.add(Person))
```

会有新的报错:

```python
AttributeError: type object 'Person' has no attribute 'x'
```

所以还需要再传入两个参数:

```python
print(Person.add(Person(3, 4)))
```

这样就可以成功运行, 返回结果7.

传入的参数应该是一个实例对象.

#### 类变量和实例变量

```python
p.z = 7  # z叫做实例变量
print(p.z)
```

重新定义Person, 添加类变量

```python
class Person:
    x = 5
    y = 6
    
    def __init__(self, x, y):
        ...
```

在实例中调用x和y的值:

```python
p = Person(1, 2)
print(p.x)
print(p.y)
```

打印结果为1, 2, 说明他们都是实例变量.

```python
print(Person.x)
print(p.add())  # 3
```



### 3-5 可变参数类型

新建`part3/args.py`

```python
# a *args **kwargs

# 考点一: 可变参数、关键字参数是什么数据类型
def function(a, *args, **kwargs):
    print(type(a))
    print(type(args))
    print(type(kwargs))

# 调用这个函数
function(1, 1, 1)
# 打印结果为
# <class 'int'>
# <class 'tuple'>
# <class 'dict'>


# 考点二: 可变参数和关键字参数如何分配
# 重新调用function
function(6,7,8,9,b=2,c=3,d=4)

# 重写function
def function(a, *args, **kwargs):
    print(type(a))
    print(type(args))
    print(type(kwargs))
    print(a)
    print(args)
    print(kwargs)
# 打印结果为
# 6
# (7, 8, 9)
# {'b': 2, 'c': 3, 'd': 4}


# 第三个考点: 
function(6,7,b=2,c=3,d=4,8,9)
# 或者
def function(a, **kwargs, *args):
	...
# 代码都会提示错误
# 即调换调用函数中参数的顺序或者定义函数中的参数的位置, 都会报错
```



### 3-6 Python装饰器详解

在别的语言中也叫注解.

创建`part3/annotation.py`

```python
import time

def runtime(function):
  def get_now_time():
    	print(time.time())
      	function()  # 这里要回调一下function
  return get_now_time

@runtime
def run():
  	print("run")


run()
```

开发一个有参数的装饰器

```python
def runtime(function):
    def get_now_time(*args):
        print(time.time())
        function(*args)
    return get_now_time
        
@runtime       
def run(i):
    print(i)
    
run("hahaha")
```

开发一个关键字参数的装饰器:

```python
def runtime(function):
    def get_now_time(**kwargs):
        print(time.time())
        function(**kwargs)
    return get_now_time
        
@runtime       
def run(a):
    print(a)
    
run(a="hahaha")
```

开发一个传入混合参数的:

```python
def runtime(function):
    def get_now_time(name, **kwargs):
        print(time.time())
        function(name, **kwargs)
    return get_now_time
        
@runtime       
def run(name, **kwargs):
    print()
    
run("hehehe", a="hahaha")
```



### 3-7 return与yield的区别

本小节主要是来说一下, 

先说一个概念: 生成器.

新建`part3/return_and_yield.py`

```python
def func1():
    for i in range(1, 5):
        return i
    
def func2():
    for i in range(1, 5):
        yield i
        
print(func1())
print(func2())
# 打印结果为
# 1
# <generator object func2 at 0x10482efc0>
```

`return` 阻断了循环

再调用一下:

```python
yi = func2()
print(type(yi))
# 打印结果为
# <class 'generator'>
for i in yi:
    print(i)
```

`yield`并不阻断循环,而是把每个结果都返回



### 3-8 多种推导式的实现

之前出的那道面试题: 一行代码实现一个新的列表.这个里面要么考的是`lambda`表达式, 要么考的是推导式.

新建文件`part_3/comprehension.py`

```python
# 根据一个列表 创建一个新的列表. 用一行代码
# 有两种方式: lambda 表达式 推导式

# 首先来看用lambda表达式如何处理
list1 = [1, 2, 3, 4]
result = map(lambda x: x * x, list1)
print(list(result))
# 打印结果为[1, 4, 9, 16]
```

`lambda`表达式相当于一个匿名函数, 函数接受一个参数`x`, 运算结果是`x * x` 

`map`有两个参数, 第一个参数是接受一个函数, 另外一个是可迭代对象.查看`map`具体的源代码: 

```python
class map(object):
    """
    map(func, *iterables) --> map object
    
    Make an iterator that computes the function using arguments from
    each of the iterables. Stops when the shortest iterable is exhausted.
    """
    def __getattribute__(self, *args, **kwargs):
        """Return getattr(self, name)."""
        pass
    
    def __init__(self, func, *iterables):
        pass
    ...
```

可以看到构造函数中的参数是可迭代对象`*iterables`.

然后看一下用推导式来解决, 就是用列表推导式

```python
list2 = [i*i for i in liist1]
print(list2)
# 打印结果为[1, 4, 9, 16]
```

列表推导式相对来说更容易理解,更优雅一些.

在列表推导式中还可以进行有条件的筛选:

```python
list2 = [i*i for i in liist1 if i > 2]
print(list2)
# 打印结果为[9, 16]
```

1和4没有了因为进行了筛选.

还有集合推导式, 就是把列表推导式的中括号变成大括号:

```python
list1 = {1, 2, 3, 4}
list2 = {i*i for i in list1}
print(list2)
# 打印结果为{1, 4, 9, 16}
```

字典推导式:

```python
my_json = {
    "key1": 10,
    "key2": 20,
    "key3": 30
}

keys = [key for key, value in my_json.items()]
print(keys)
# 打印结果为['key1', 'key2', 'key3']

# 应用: 让key和value颠倒 (结果是一个字典)
keys1 = {value: key for key, value in my_json.items()}
print(keys1)
# 打印结果为{10: 'key1', 20: 'key2', 30: 'key3'}
```

也可以加一些筛选条件:

```python
keys2 = {key: value for key, value in my_json.items() if key == "key1"}
print(keys2)
# 打印结果为{‘key1': 10}
```



### 3-9 排序算法的复杂度解释

本小节说一下常见的排序算法:

新建`/part_3/sort.py`

```python
"""
常见的排序算法:
插入排序、希尔排序、直接排序、堆排序、
冒泡排序、快速排序、归并排序、基数排序
"""
```

一道阿里的面试题:

给定一个列表, 将这个列表进行排序, 要求: 时间复杂度要小于O(n^2)

复杂度:

1. 时间复杂度: 指算法在计算的过程中所需要的计算工作量
2. 空间复杂度: 指算法在计算的过程中所需要的内存空间

常见的时间复杂度:

常数阶:`O(1)`, 对数阶`O(log2n)`, 线性阶`O(n)`, 线性对数阶`O(nlog2n)`, 平方阶`O(n^2)`, 立方阶`O(n^3)`

随着问题的规模n不断增大, 上述的时间复杂度就不断增大, 意味着算法的执行效率越来越低.

回到阿里的那道面试题,时间复杂度要小于`O(n^2)`, 那就是要选平方阶前面的那些复杂度.

### 3-10 冒泡排序的时间复杂度及思想

冒泡排序的实现:

相邻的两个数字进行比较, 大的向下沉, 最后一个元素是最大的.

时间复杂度`O(n^2)`

```python
def bubble_sort(blist):
    # 首先要获取整个list的长度以控制循环的次数
    count = len(blist)
    for i in range(0, count):
        for j in range(i+1, count):
            if blist[i] > blist[j]:
                # 使用python特有的方法来进行两数交换
                blist[i], blist[j] = blist[j], blist[i]
    return blist

blist = bubble_sort([32, 12, 45, 64, 1, 5, 8])
print(blist)
# 打印结果为[1, 5, 8, 12, 32, 45, 64]
```



### 3-11 快排的时间复杂度及实现思想

快速排序的基本实现思路: 递归

列表中取出第一个元素,作为标准.把比第一个元素小的都放在左侧, 把比第一个元素大的都放在右侧

递归完成的时候就是排序结束的时候

快速排序的时间复杂度`O(nlog2n)`, 所以快排是符合阿里面试题的要求的

```python
def quick_sort(quick_list):
    if quick_list == []:
        return []
    else:
        first = quick_list[0]
        # 推导式实现
        less = quick_sort([l for l in quick_list[1:] if l < first])
        more = quick_sort([m for m in quick_list[1:] if m >= first])
        return less + [first] + more

blist = quick_sort([32, 12, 45, 64, 1, 5, 8, 10, 15, 99])
print(blist)
  	
c0 a8 1f 60 c0
```



## 第4章 一面-面向对象、函数式编程面试真题

### 4-1 面试真题及考点分析

#### 面向对象面试真题

1. 概述如何理解面向对象以及面向对象的特点

一般的同学看到这个题目的时候上来就回答面向对象的特点,然后就讲继承、封装和多态,然后就讲什么是封装什么是多态什么是继承.

这道题考的第一个问题是什么?我们来分析一下,如何理解面向对象,所以首先要讲一下怎么理解面向对象.然后再讲面向对象的特点.

那为什么要问你是怎么理解面向对象的呢,大家都知道面向对象是一种编程思想. 在程序设计的时候你能不能够把面向对象的这种程序设计理念应用好这个才是这道题真正想问的, 也就是你的编程思想掌握的有多深, 其实从这个问题侧面了解到你的代码量有多大.如果代码量写的少, 就这样的一个 开放式问题, 每个人回答的深度都不同.每个人的理解都不同.

2. 类中的私有变量是否能访问,如果能,那么如何访问?

这道面试题得看问什么样的语言, 因为我们课程都是讲的Python所以针对的就是Python语言, 考的考点就是你对Python语言底层的关于私有变量的封装是否了解, 你之前有没有注意到.

3. Python中的类有多少方法种类, 他们有什么区别?

这也是针对Python的类进行的一个考核.

考点是:是之前讲过的一个概念.类对象实例对象,里面还有一些方法:类方法、实例方法和静态方法.你对这三种方法到底有怎样的理解.

这里面可以拆分成两个问题 ,第一个问题是Python中的类有多少种方法,然后他们有什么区别. 也就是说这几个方法你在调用的时候或者说在面向对象这种编程思想的体现过程中,你具体是怎么应用的, 因为其实问类相关的东西,也都是你对面向对象整个这个思想的体现,什么时候应该用实例方法,什么时候应该用类方法, 又什么时候应该用静态方法.

整个来说都是对面向对象编程的思想的具体体现. 第一个问题是比较抽象的, 第三个问题是应用起来比较落地的,看你能不能具体吃透. 因为要是你概念上回答的很清楚但是具体方法上回答的不清晰, 那么他也会对你的编码能力产生质疑.

#### 函数式编程面试真题

1. 用函数实现过滤掉集合`list1 = [‘’, ‘hello’, None, ‘python’]`中的空格和空值

你用if判断也能实现. 使用过程也都是函数的使用过程, 也就是看你对Python那几个常用函数使用的是否熟练, 数据处理的时候就有可能用这个函数. 应用到这个函数的时候就要处理一下.假设说后台返回了值包含了一些空格, 或者我们很多人准备测试数据准备中有点疏漏写的不是很标准, 也可以用这种方式来去除. 再比如说前端输入用户名和密码. 两端的空格, 中间的空格就不用过滤掉.中间的一般是他故意输入的. 两遍比如填一些表单的时候, 当然我们自己在测表单的时候.

2. 用函数方法实现计算集合`list1 = [1, 2, 3, 4, 5]`中, 所有元素的和?

这个考的也是Python中一个函数的使用.

这两个都是非常具体的考点, 会就是会, 不会想也想不出来.

### 4-2 Python 中的私有变量能访问么

新建`part_4`包, 新建`private_var.py`

私有变量能访问么? 怎么就成私有变量了呢

```python
class Student:
  	__name = "三毛"
    school = "北大"
    
print(Student.school)
print(Student.__name)   # 报错: AttributeError: type object 'Student' has no attribute '__name'
print(dir(Student))
```

在Python中对私有变量如何封装的?

### 4-3 Python中类的方法种类及区别

新建`function_type.py`

```python
class Student:
  	name = "四毛"
  	
    def eat(self):	# 实例方法. 实例可以操作的方法, 可以操作实例变量
      	self.name = "三毛"
      	print("学生吃")
        print(self.name)
       
    @classmethod
    def study(cls):		# 类方法, 类可以直接调用, 可以操作类变量
      	print(cls.name + "student study")
        
    @staticmethod
    def run():			# 静态方法 脱离了类而存在的 跟类没有什么关系 写工具
      	print("student run")
        
    def __kaoshi(self):
      	print("学生考试")
        
        
    
Student.eat()   # 报错: TypeError: eat() missing 1 required positional argument: 'self'
s = Student()
print(dir(Student))
Student.study()  # 可以打印出 s tudent study
Student.run()


```

### 4-4 我对面向对象的理解

新建 `如何理解面向对象.txt`

一切皆对象, 万物皆对象

面向对象首先是一种编程思想

我的理解: 是编程世界向现实世界的一种延伸, 也就是万物皆可描述

我们用编程语言也可以描述世界万物.



类: 它就是面向对象的一种表现形式

大象放冰箱里分几步?

1. 打开冰箱
2. 装进大象
3. 关上冰箱

打开和关闭是冰箱的方法.

### 4-5 面向对象三大特性演示

新建包`/part_4/foo/`, 新建`animal.py`

```python
class Animal:
  	def run(self):
      	print("animal run")
        
    def eat(self):
      	print("animal eat")
        
    def talk(self):
      	print("animal talk")
        
a = Animal()
a.run()		# 打印出 animal run


class Person(Animal):   # 继承
  	def study(self):
      	print("person study")
        
    def talk(self):
      	print("person talk")
        
class Dog(Animal):
  	def talk(self):
      	print("dog talk")
        

p = Person()
print(p.eat())  # 打印 animal eat
p.talk()
d = Dog()
d.talk()
```



## 第5 章 一面-网络知识面试考点

### 5-1 网络面试真题及考点分析

1. 请说明 session 和 cookie 的作用和区别
2. HTTP 协议如何保证数据在传输过程中不丢失

考点是: 网络协议分层, 包括三次握手, 四次挥手. 比如 UDP 

1. 简要说明请求头中`Accept`\``Accept-Encoding``\``Accept-Language``都代表了什么意思

这几个字段是在请求头信息中, 我们都可能带一些请求头信息. 

它在初始验证的时候, 以作为身份标记. 

### 5-2 cookies 和 session 的存储和区别

本小节说一下 cookie 和 session 是怎么工作的,他们的机制是什么.

那么什么是 cookie? 首先来看一下 cookie 和 session 在应用程序中是如何工作的?



我们在访问一个应用程序的时候, Web 浏览器这种B/S 架构的首先打开一个浏览器,  这个时候按下F12弹出开发者工具的框, 在那里可以看到cookie的存储情况. 它是一系列key和value组成的字符串, 当我们第一次见到他们的时候并不知道他们代表什么意义, 除非一一地和后端开发工程师核对才能知道字符串是怎样生成的, 后端是如何验证的. 

但实际上cookies 是怎么来生成的呢? 其实cookie就是相当于「身份令牌」的一种东西, 前端要拿着这个「身份」去访问后端, 也就是要访问到服务器上(服务器可以理解为后端的代码, 后端代码有一部分业务逻辑在上面), 它要拿着cookie里边这么多的字段里边的值来进行验证, 后端验证完成后 session 信息就是在服务器上了. 这里就是他们

第一个区别: cookie是存储在客户端的, 存储在客户端意味着用户可见; 用户可见就说明那些有不法意图的人也能看见, 所以说cookie信息是可以伪造的. 为了保证安全机制, 我们应该还在服务端存一个东西, 让用户看不见, 这个就是session. session 其实是服务端生成的一个字符串.

那 session 信息一般在服务器上是怎么存储的呢?

其实存储到哪里都可以, 只要写在服务器上. 只是他们之间各有优缺点, 比如说我们常见的存储session的位置有: 一般情况下比较容易实现的是存储在数据库中, 像Redis中, 这里的「数据库」指的并不是MySQL, 当然你非要存在MySQL里也行. 比如说上面我列了一个「文件」, 存储到文件里和存储到MySQL数据库里道理是一样的, 缺点是要自己维护session过期时间. 比如说session会话要保持它的过期时间在10分钟, 那你就要自己计时, 到10分钟以后清除这个session. 如果要存到 Redis 数据库中, redis有一个自己维护key的机制, 存进去的时候就可以自动设置一个过期时间, 所以数据库里自动就维护了session里边一系列的「串」, 那你的应用程序只管往里写和往外拿,一个「写」一个「读」, 「读」不到了就意味着 session 过期了. 所以说存储到redis中有这样一个好处.

通过这样一个简要的图, 大家应该能明白「cookie 是存储在客户端的, session 是存储在服务端的」.

再说一下整个网络请求运转的流程: 最早的 cookie 信息其实也是服务器生成之后返回给Web的, 由服务端来生成的原因是: 首先因为服务端有自己的计算规则, 每当一个 Web 页面(或者理解为一个用户)来访问服务器的时候, 服务器必须要知道你是谁, 那么服务器怎样来计算呢: 其实可以通过Web页面传给它的一些信息来进行加密, 当然这些信息看我们怎么选择, 可以是用户名、密码, 包括一些头信息加到一块来进行计算. 当然每个公司或每个系统有不同的算法. 所以说你看到这个cookie的时候, 每次访问都不一样, 就是因为有一部分信息是变化的. 整个过程一开始是Web页面访问服务器, 服务器生成cookie返回给Web, Web存储, Web再拿这个cookie访问服务器, 服务器再验证这个cookie到底是不是合法的, 然后再返回给Web, 中间验证的过程就生成了session, 然后就存储起来了.它是这样的一个过程.

#### 区别

1. cookie 在客户端的头信息中

   ​	在头信息中会有一个cookie字段

2. session 在服务端存储, 文件、数据库等都可以

3. 一般来说session的验证需要cookie带一个字段来表示这个用户是哪一个session, 所以当客户端禁用cookie时, session 将失效.

#### Cookie 的总结

##### 慕课网登录后的cookies

```html
Cookie: imooc_uuid=43b08dd1-53e2-41b4-a8f2-d000d8b38efb; imooc_isnew_ct=1583568616; imooc_isnew=2; sensorsdata2015jssdkcross={"distinct_id":"2854754","first_id":"1721bf561dc3a4-0e088ef26f5c3e-30607700-2073600-1721bf561dd69e","props":{"$latest_traffic_source_type":"直接流量","$latest_search_keyword":"未取到值_直接打开","$latest_referrer":""},"$device_id":"1721bf561dc3a4-0e088ef26f5c3e-30607700-2073600-1721bf561dd69e"}; adv_#globalTopBanner_3181=1604426562045; adv_#globalTopBanner_3270=1604930701858; adv_#globalTopBanner_3376=1608223302094; adv_#globalTopBanner_3378=1608573273471; Hm_lvt_f0cfcccd7b1393990c78efdeebff3968=1609934514,1610884740; sensorsdata2015jssdkcross={"distinct_id":"2854754","first_id":"1721bf561dc3a4-0e088ef26f5c3e-30607700-2073600-1721bf561dd69e","props":{"$latest_traffic_source_type":"直接流量","$latest_search_keyword":"未取到值_直接打开","$latest_referrer":""},"$device_id":"1721bf561dc3a4-0e088ef26f5c3e-30607700-2073600-1721bf561dd69e"}; loginstate=1; apsid=VlMzIyOGQ0NDNjZDQ5YjQ2MWFiY2E5OTRmMjhkODQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjg1NDc1NAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABncmVnb3J5c2hlbkAxNjMuY29tAAAAAAAAAAAAAAAAAGY1MmYwY2EzYjA4MmY1NjE2YWIxZTk1MjMzMDEyYTc1/EsQYN/5NF8=Nz; last_login_username=gregoryshen@163.com; Hm_lvt_c1c5f01e0fc4d75fd5cbb16f2e713d56=1611077418,1611927096; Hm_lpvt_f0cfcccd7b1393990c78efdeebff3968=1611931532; zg_did={"did": "170b40bf4e31ab-0072a681473031-396d7406-13c680-170b40bf4e4a4a"}; zg_f375fe2f71e542a4b890d9a620f9fb32={"sid": 1611931532447,"updated": 1611931532447,"info": 1611931532455,"superProperty": "{\"应用名称\": \"诸葛io\"}","platform": "{}","utm": "{}","referrerDomain": "coding.imooc.com","cuid": "lEhff_eIb8s,","zs": 0,"sc": 0,"firstScreen": 1611931532447}; IMCDNS=0; Hm_lpvt_c1c5f01e0fc4d75fd5cbb16f2e713d56=1612090998; cvde=60042684163f2-84
```

最前面有一个 `Cookie` 字段, 后面有一些key和value用等号来进行连接. 这么看根本不知道这些key和value代表什么, 当然他们有自己的计算规则, 要知道算法要跟开发沟通.

##### Cookie 的总结

* cookie 就是一小段文本信息

* cookie 的格式为key: value; key: value(每一个key对应一个value, 后端验证的时候也是首先拿到这个key进行匹配, 然后再计算value, )

* cookie 的值由服务端生成, 客户端保存

> 扩展: [前后端常见的几种鉴权方式](https://juejin.cn/post/6844903927100473357) 中 session-cookie 的部分
>
> 3.1 cookie
>
> http 协议是一个无状态协议, 服务器不会知道到底是哪一台浏览器访问了它, 因此需要一个标识来让服务器区分不同的浏览器. cookie 就是这个管理服务器与客户端之间状态的标识.
>
> cookie 的原理是, 浏览器第一次向服务器发送请求时, 服务器在 response 头部设置 Set-Cookie 字段, 浏览器收到响应就会设置 cookie 并存储, 在下一次该浏览器向服务器发送请求时, 就会在 request 头部自动带上 Cookie 字段, 服务器端收到该 cookie 用以区分不同的浏览器. 当然, 这个 cookie 与某个用户的对应关系应该在第一次访问时就存在服务器端, 这时就需要session了.
>
> 3.2 session
>
> session 是会话的意思, 浏览器第一次访问服务端, 服务端就会创建一次会话, 在会话中保存标识该浏览器的信息. 它与 cookie 的区别就是 session 是缓存在服务端的, cookie 则是缓存在客户端, 他们都由服务端生成, 为了弥补 http 协议无状态的缺陷.
>
> 3.3 session-cookie 认证
>
> 1. 服务器在接受客户端首次访问时在服务端创建session, 然后保存session(我们可以将session保存在内存中, 也可以保存在redis中, 推荐使用后者), 然后给这个session 生成一个唯一的标识字符串, 然后在响应头中种下这个唯一标识字符串.
> 2. 签名. 这一步通过密钥对sid进行签名处理, 避免客户端修改sid(非必需步骤)
> 3. 浏览器中收到请求响应的时候会解析响应头, 然后将sid保存在本地cookie中, 浏览器在下次http请求的请求头中会带上该域名下的cookie信息.
> 4. 服务器在接受客户端请求时会去解析请求头cookie中的id, 然后根据这个sid去找服务器端保存的该客户端的session, 然后判断该请求是否合法.
>
> 3.4 redis
>
> redis 是一个键值服务器, 可以专门放session的键值对.
>
> 3.5 用户登录认证
>
> 使用 session-cookie 做登录认证时, 登录时存储 session, 退出登录时删除session, 而其他的需要登录后才能操作的接口需要提前验证是否存在session, 存在才能跳转页面, 不存在则回到登录也main.

### 5-3 OSI网络协议分层详解

要记住中间各层是干什么的.

|            |                              |
| :--------: | :--------------------------: |
|   应用层   |      为应用程序提供服务      |
|   表示层   |    数据格式转化及加密操作    |
|   会话层   |     建立、管理和维护会话     |
|   传输层   | 建立、管理和维护端到端的连接 |
|   网络层   |       IP地址及路由选择       |
| 数据链路层 |    提供介质访问和链路管理    |
|   物理层   |      物理层, 即物理设备      |

#### OSI 七层协议与TCP/IP五层协议及对应网络协议





### 5-4 HTTP协议数据不丢失的网络机制

#### HTTP三次握手机制

客户端和服务端进行握手.

seq码, 主机b拿到syn=1, Seq=1

第二次握手: 服务端收到请求后发送, 要给你返回一个信息, 确认信息ACK=x+1, 

第一次握手和第二次握手,

第三次握手: 检查ACK number是不是正确, 

建立连接, 数据传输.

#### HTTP四次挥手机制

FIN是结束的标语, 告诉服务端,数据传输完了, 可以关闭

服务端接受到ack=u+1, seq=v, ack=1

第二次挥手的时候是半关闭状态

第三次挥手: 服务端发送给客户端: FIN=1, ack=u+1, seq=w, ack=1

第四次挥手: 客户端到服务端: ack=w+1, seq=u+1, ack=1

最后: 连接断开



### 5-5 HTTP协议信息头详解

#### 请求头

HTTP协议信息头

常用请求头:

`Accept`: 浏览器告诉服务器它所支持的数据类型

`Accept-Charset`: 浏览器告诉服务器它采用的字符集

`Accept-Encoding`: 浏览器告诉服务器它所支持的压缩格式

`Accept-Language`:

`Host`: 浏览器告诉服务器我想访问服务器哪台主机

`If-Modified-Since`: 浏览器告诉服务器它缓存数据时间是多少

`Referer`: 浏览器告诉服务器我是从哪个网页点过来的(防盗链)

`User-Agent`: 浏览器告诉服务器我所使用的浏览器类型、版本等信息 





## 第6 章 一面-Web自动化面试考点

### 6-1 Web自动化面试真题及技术点讲解

1. 你的自动化是如何落地的? 遇到了什么难点?

   可以把这个问题拆解成两个, 第一点你要讲清楚你是怎么落地的, 第二点你要顺着你如何落地这个思路去讲你遇到了哪些难点. 这两步都要讲清楚, 如何落地的时候要说清楚整个项目流程是什么样的, 怎么落地, 你都是怎么做的,做了哪些工作,把这些事说清楚, 然后再说清楚你在落地过程中遇到了什么问题并且解决了什么问题. 一定不能光抛出问题, 要把解决问题的思路展现出来, 这样你才能够凸显出你跟别人的不同, 凸显出你的价值. 

   这个更偏向于工作思路的分析, 你说你做过自动化测试,那你是怎么做的, 你要把这个事讲清楚, 如果一旦没有讲清楚那就会被怀疑你是不是没做过啊. 

2. 遇到过哪些比较难定位的元素, 你是如何定位的

   一个真正做过自动化测试的人, 肯定遇到过比较难定位的元素, 因为不可能都用那几个`find_element_xx`这种东西都搞定, 不可能的. 一定有一些元素难定位, 你要把这个事讲出来, 你不能直接说的非常平淡, 然后再讲你是通过什么方式去定位的. 

   这个问题首先要讲一个深度, 讲的问题越难越深, 证明你自动化方向做的越深入. 这道问题看着挺简单, 你可能随便答两句就过去了, 但是实际上你在面试官那里留下的印象是不一样的.

3. 验证码的问题你是如何解决的?

   你是怎么解决验证码的, 验证码, 凡是 Web 的操作系统都有验证码, 我们在做自动化的时候都会碰到验证码的问题, 那你是怎么解决的. 那解决思路, 我讲思路, 因为 Web 自动化这块思路就会多一些, 在面试过程中真正让你写代码的部分还是在基础编程语言那块, 自动化这块更多的是问, 通过聊天的方式了解你对自动化到底做的深不深入. 验证码是绕不过去的一个问题, 基本上做 Web 自动化大家都会问.
   
4. 你的自动化框架是如何设计的? (一个更开放但是相对来说也是比较难回答的问题)

   框架设计要针对做的过程中遇到的一些痛点, 然后来解决这个痛点, 这才是框架设计的根本出发点. 如果你的出发点只是为了自己写的爽, 像过去写自动化代码一个元素定位然后一个操作, 全都往下走, 那么我们面临的问题就比较明显, 明显在如果业务一旦出现分支操作, 前面的流程都要走一遍. 比如说登录, 你过去做自动化的时候, 如果你没有好的设计框架的思想, 每次跑的时候是不是有很多多余的步骤.

以上是 Web 自动化面试比较常见的几类问题.

### 6-2 Web自动化落地过程和难点剖析

首先把我们整个的项目流程梳理一下:

```mermaid
graph LR
A(立项) -->B(文档)
B --> C(代码编写)
C --> D(单元测试)
D --> E(测试准入)
E --> F(功能测试)
F --> G(性能测试)
G --> H(集成测试)
H --> I(测试报告)
I --> J(上线部署)
J --> K(线上回归)
```

首先我们在接触一个项目的时候, 比如说这个项目从头开始, 需要经过立项, 然后有一些文档产出, 做代码编写, 这个过程有的同学说我们公司就没有文档产出, 一切文档都没有, 都是通过口述. 这个没关系, 这是列了一下算是相对来说比较健全的一个项目流程, 你公司没有的话, 没有关系, 大部分的项目整体运转的流程是这样的. 

然后做单元测试, 如果没有单元测试也没有关系. 但是几个关键的点会强调一下. 

然后还有测试准入. 测试准入这块很多公司都没有测试准入, 会发生的问题: 开发人员提过来代码, 一提测刚测几个卡住了, 打回去,又改又提测刚测几个就打回去, 这就是没有测试准入的一个效率不高的地方, 所以说在未来推进自己公司测试流程建设的时候一定要建立一个准入的门槛, 把这个门槛给到开发同学, 让开发的同学自己跑一遍. 

准入之后就是做功能测试, 准入测试代表了它已经完成了最基本的要求, 也就是冒烟测试, 但是这个准入它是一个更系统的测试, 之后还有更多的功能测试流程, 功能测试之后是性能测试, 性能测试之后做集成测试, 集成测试之后产出一个测试报告, 测试报告之后我们会发布上线, 由运维的同学把产品工程部署到线上, 然后我们再做一个线上回归, 差不多包含了大部分项目的生命周期或者在企业中的流程. 此时此刻思考一个问题:

什么时候开始自动化才是最好的时间点呢?

你的自动化代码一定要多用, 用的越多才能体现出你这个自动化的价值, 如果你写代码花了一周, 写完了就一个小环节在用, 或者干脆没用起来, 那根本就不行. 面试时很有可能有一些刁钻的问题, 答不上来那就很尴尬了.

我们一共有3个自动化的切入点:

* 测试准入

  为什么测试准入放在第一个点: 比如说我们有一个准入门槛, 我写了一堆测试用例我告诉开发同学你再提测必须把这些测试用例都跑了, 都测试通过了才能把你的程序交给我让我测, 你觉得开发同学会听你的话吗? 他们会跑吗? 他连自己的单元测试都懒得写, 所以这种方案是不现实的. 现实的情况是你把自动化的部分写好, 一旦他提测了, 提测之后把应用程序也得部署到测试环境上, 或者搞持续集成, 持续集成里把他这个单个模块不管怎么样部署到服务器上, 部署完之后用自动化跑一遍, 自动化没跑过就打回去, 让他重改, 然后再跑. 所以说测试准入是自动化的第一个切入点, 如果这里把关把的比较好, 那么测试就不再成为一个背锅的岗位, 也不会产生项目延期了, 测试同学没测完, 你把你这个时间点记清楚.  

* 集成测试

  集成测试是另外一个比较重要的自动化的切入点. 集成测试把我们所有的模块, 所有的应用程序, 内部的外部的, 都可以叫集成. 代码放一起能不能出问题呀, 先拿自动化这套跑一遍看一看, 如果大部分流程OK了, 或者说符合自动化场景的都OK了, 回头再做跑一遍其他的功能、性能, 形成一个循环. 因为功能测试, 性能测试和集成测试是可以来一个循环的.

* 线上回归

  线上回归也可以先用自动化跑一遍, 如果自动化弄不好的话可能部署那块有问题, 然后就重部了呗. 但是线上测试的时候并不会再经过像线下那样特别复杂、用例特别多的测试, 但是可以用简单的自动化来回归一遍.

这里面关于自动化就有三个切入点, 你给你的面试官去讲你的自动化落地的时候, 是不是可以把这三个点讲清楚, 那你的价值可以最大化, 并且这只是给大家提一个建议, 如果你在你具体的工作场景中,或者结合你的业务有更多的切入点的时候, 你也都要讲清楚, 把这些都加进来. 虽然我们很多个切入点,  列出来的这三个个很有可能是一套代码, 但没有关系, 一套代码才证明你的自动化的代码写得好, 不要因为代码量的多与少对自己能力产生怀疑.

面试的过程当中可以多提一些数字, 比如每次跑自动化的时候可以让代码自动记录运行的次数, 将来它有可能是面试的资本. 你可以讲在我的自动化在我之前负责的项目, 一共跑了38675次, 做自动化之前你的这几个环节, 每个环节用了多长时间, 那你跑的三万多次. 再回归到刚才关于切入点, 次数以及效率的问题, 为啥要让大家记住具体的执行次数, 是不是讲出自己这套自动化落地的价值,所以讲述落地过程的时候要把价值体现出来, 价值体现非常直观的就是数字, 你直接给面试官一个数字, 他就能非常好量化你的价值. 这是落地过程中比较重要的点.

再来把它作为重点强调一下:

一个是自动化切入点讲的越多越好

第二个是你的自动化所产生效率的提高, 对应的数字是什么?  

#### 落地过程中具体难点有哪些

* 前端代码改动大、频繁或命名不规范导致元素不好定位

  尤其是刚开始做自动化的同学, 尤其是现在我对自动化的整体技术还不那么强的时候, 然后你搞一个元素,前端交互特别复杂, 我定位不到, 这是我自身的原因. 你可以给他讲: 我一开始做自动化的时候可能会出现这样的问题, 我自己要克服, 我怎么克服, 然后你去给他讲你是通过哪些方式来学习的, 这个问题是不是就引出了另外一个问题, 就是你遇到了哪些元素不太好定位是不是引出下面的面试题. 

  就是说在面试的过程中你要尽量的去主导面试, 你要给面试官一个惯性思维, 比如说我遇到了元素不好定位的问题, 有的面试官就会下意识的问你: 你都碰到了哪些元素不好定位啊, 你就把提前准备好的问题都讲清楚, 就是引导方式的一种, 你要给他一个问你的理由.

* 自动化刚开始时,测试人员编码规范及架构设计不统一

  到公司的时候测试人员有很多, 一般也不可能就你一个人, 一个人也不能说就一个人, 可能跟别人没有沟通不太好. 如果一个人的时候怎么说呢, 你就不能说测试人员编码规范以及测试架构设计不统一了. 你要说你引领了什么,主导了什么, 把什么什么落地了. 
  

这里说的是面试过程中一些难点. 这个问题引导出面试官会问你: 你是怎么解决这个问题的, 你就跟他讲我这个架构是怎么设计的, 我主导我们自动化的测试架构, 然后做了哪些规范的事, 再让测试同学根据规范大家一起做, 然后我们做到整个做到架构统一, 编码也规范了, 用什么工具做的编码规范, 用什么做代码管理, 架构分层是怎么设计的. 这里边强调的是你讲难点可以, 你要想清楚你把难点讲出来的时候面试官会问你什么问题, 要把下面的问题想清楚, 这个就是引导的一种. 这个思路, 难点一定不要乱说, 乱说的话你又没解决面试张嘴再问了你是怎么解决的你就尴尬了. 所以说难点一定要想清楚.

### 6-3 下拉框定位

下拉框的定位方法:

新建 `scrool_bar.py` 滚动条是怎么定位的

```python
from selenium import webdriver

option = webdriver.ChromeOptions()
option.add_argument('disable-infobars')

driver = webdriver.Chrome(chrome_options=option,
                          execute_path="/path/to/chromedriver" )
driver.get("https://www.jd.com")

driver.set_window_size(600, 800)

js = "window.scrollTo(0, 10000);" # 第一个参数是横向的参数, 第二个参数是纵向的, 10000代表最下/右
driver.execute_script(js)
```



### 6-4 定位日期控件及js调试方法

时间控件如何定位

出发日期是一个 input 输入框, 有一个 readonly 属性,  提供一个思路 js, 在 selenium 是可以运行 js 脚本的. 

```python
driver.get("https://www.12306.cn/index/")


train_date = 

js = "document.getElementById('train_date').removeAttribute('readonly')"
driver.execute_script(js)

driver.find_element_by_id("train_date").clear()
driver.find_element_by_id("train_date").send_keys("2018-12-12")
```

调试js的小技巧:

在console中: `document.getElementById('train_date')`

### 6-5 页面弹出框的处理



### 6-6 浏览器自带弹出框定位



### 6-7 浏览器句柄切换

就是每个浏览器的标签, 就可以称为句柄.

新建 `switch_handlers.py`

```python
driver.get("http://www.sohu.com")
window = driver.current_window_handle
windows = driver.window_handles

for current_windows in windows:
    if current_windows != window:
        driver.switch_to.window(current_windows)
time.sleep(2)
driver.quit()
```

以上是之前常见的写法, 除此之外之外还有下面的写法: 

```python
driver.find_element_by_link_text("新闻").click()
windows = driver.window_handles
driver.switch_to.window(windows[-1])
time.sleep(2)
driver.quit()
```

### 6-8 验证码解决思路

这个问题被问到的概率非常大

新建 验证码问题解决思路.txt

1. 第一反应是识别, 识别这个思路是想正面突破, Python 中提供了一部分图片验证码识别的库

   或调用别人免费的 API 接口, 比如: 百度 AI 开放平台、腾讯优图

2. 万能验证码: 开发同学提供的. . 你不用输, 开发同学后面的接口逻辑, 缺点是开发有工作量. 到生产环境这个逻辑需要去掉, 所以到生产环境

3. Debug : 手工输入后, 再执行代码点击登录. 缺点: 不能持续集成.

4. 到数据库中拿:

   ​	验证码生成逻辑: 后端有一个算法, 生成验证码, 保存后传给前段, 前端展示保存的位置: 数据库(Redis: 自己维护过期时间)

   测试同学就到这个 Redis 中读一下这个验证码就可以了. 图片也是数据的一种, 它在数据库中就是一个字符串. 这里作为测试同学, 需要搞清楚一个逻辑:  身份验证.

### 6-9 如何保证元素定位的成功率

等待有哪几种方法, 或者说比较合理的等待方法有什么. 

新建文件 `wait.py`

```python
import time
time.sleep(2)
```

它的弊端, 你自己写代码的时候它这种强制等待就不能用了. 

```python
# 隐性等待
from selenium import webdriver
driver. = webdriver.Chrome(execute_path="xxx")
driver.implicitly_wait(5)
driver.get("https://www.baidu.com")
print(driver.current_url)
driver.quit()
```

隐性等待设置的是最长等待时间, 只有在页面完全加载完才执行下一步

什么叫完全加载完成? 左上角的圈不再转了

合理的一种加载方式: 检测我的元素, 是否被加载到.

隐性等待对整个 driver 的周期都起作用, 只要设置一次就可以了.

```python
# 显性等待
from selenium.webdriver.support.wait import WebdriverWait
from selenium.webdriver.support import expected_conditions as ec
from selenium.webdriver.common.by import By

driver. = webdriver.Chrome(execute_path="xxx")
# 隐性等待和显性等待是可以同时使用的, 等待的最长时间取决于两者之中的最大者
driver.get("https://www.baidu.com")
WebDriverWait(driver, 15, 0.5)\
		.until(ec.presence_of_element_located((By.LINK_TEXT, "登录")))
print(driver.find_element_by_link_text("登录").get_attribute('href'))
```

他把, 一旦超过设定这个时间, 

正常:

```python
try:
    
finally:
    driver.close()
```

`WebDriverWait` 方法

### 6-10 框架设计PO模式BasePage封装

PO 模式的代码, 然后再总结

创建一个文件夹 PO, 有一个文件夹的层次, 新建包 pages, 每个页面都要, 首先我们登录, 它需要, 还要有一个testcase 包, 还有一个配置项 settings , 

`base_page.py`

```python
from selenium.webdriver.support.

class BasePage(object):
    def __init__(self, driver, url):
        self._driver = driver
        self.url = url
        
    def open(self):
        self._driver.get(url=self._url)
        
    def find_element(self, *locator,timeout=None):
        try:
        	self._init_wait(timeout).\
        		until(ec.visibility_of_element_located(locator=locator))
        except (NoSuchElementException, timeoutException):
            self._driver.quit()
            raise TimeoutException(msg="定位元素失败, 方式为{}".format(locator))
    
    def send_keys(self, webElement, keys):
        webElement.clear()
        webElement.send_keys(keys)
        
    def _init_wait(self, timeout):
        if timeout is None:
            return WebDriverWait(driver=self._driver, timeout=settings.UI_WAIT_TIME)
        else:
            return WebDriverWait(driver=self._driver, timeout=timeout)
```

`settings.py`

```python

```



### 6-11 框架设计PO完整封装

基本页面类封装完后, 下面一个是浏览器引擎, 

新建 `browser_engine.py`

```python
from selenium import webdriver

class BrowserEngine:
    def init_driver(self):
        option = webdriver.ChromeOptions()
        option.add_argument("disable-infobars")
        driver = webdriver.Chrome(chrome_options=option)
```

新建一个登录

```python
from selenium.webdriver.common.by import By
from part6.po.pages.base_page import BasePage

class LoginPage(BasePage):
    url = ""
    username = (By.ID, "")
    
    def __init__(self, driver):
        super().__init__(driver=driver, url=self.URL)
        
    def login(self):
        self.open()
        # * 是一个元祖的list
        self.send_keys(webElement=self.find_element(*self.USERNAME), keys=aa)
        self.send_keys(webElement=self.find_element(*self.PASSWORD), keys=bb)
```

最后登录的case

```python
from part6.

class Test:
    driver = BrowserEngine().init_driver()
    
    def test_login(self):
        LoginPage(driver=self.driver).login()
        
        
t = Test()
t.test_login()
```



### 6-12 PO模式总结

#### PO 为什么会出现?

页面对象模型, 为了解决当页面特别多的时候, 我们的代码更容易维护, 每个页面都封装好, 其实就是起到一个更好的维护.

#### PO 是什么? 

Page Object, 是一种设计模式, 用来管理和维护一组 web 元素的对象库

在 PO 模式下, 应用程序的每一个页面都有一个对应的 page class

每一个 page class 维护者该页面的元素集合和操作这些元素的方法. 

#### PO 的优势?

1. PO 提供了一种业务流程与页面元素分离的模式, 这使得测试代码变得更加清晰
2. 页面对象与用例分离, 使得我们能够更好的复用对象
3. 可复用的页面代码会使得我们的代码风格更加优化

### 6-13 UI自动化必问面试题

1、selenium框架中driver的quit方法和close方法有什么区别？

2、selenium框架中鼠标悬停用什么方法？

3、selenium框架中等待有几种方法，都是什么区别？

4、在UI自动化中，是否使用过cookie，如果使用过，那么使用场景和方法是什么？

## 第7章 一面-接口自动化与持续集成面试考点

### 7-1 接口自动化落地过程详解

```mermaid
graph LR
立项(立项) --> 文档(文档)
	文档 --> 代码编写(代码编写)
	代码编写 --> 单元测试(单元测试)
	单元测试 --> 测试准入{测试准入}
	测试准入 --> Web自动化(Web自动化)
	测试准入 --> 接口自动化(接口自动化)
	测试准入 --> 功能测试(功能测试)
	功能测试 --> 性能测试(性能测试)
```

这里仍然是, 

书写文档的阶段. 在文档阶段, 你要了解整个的测试流程, 他们有没有写接口文档, 那么你的接口文档, 后面就是代码编写的过程, 并不仅仅是代码人, 可以写一些接口自动化的测试代码. 给大家一个正面的回答是这样的, 你要保证文档的实时更新, 你自己的心态, 变对于我们自己的遇到了事情越难做, 考虑的越周全, 技术能力就会得到飞速的提升, 再往下进入单元测试, 本来期望是, 测试同学在这块并不是 

再往后就是测试准入, 同时也要跑接口自动化, 能够给你打通, 并且把我的整个经验, 那你的接口自动化就跑起来了, 哪怕只有一些正向的流程, 然后就是功能测试, 然后就是集成测试, 有 Web 自动化, 让你的用例数据更加丰富, 覆盖度才能上来, 覆盖度上来了, 自动化代码的价值就越大, 作为测试人员的产出就越有意义, 你在整个项目组中, 再往后就是集成功能测试, 然后就是上线部署, 然后做线上回归, 最后做 web 自动化、接口自动化和性能测试. 有一部分 Web 自动化在接口自动化, 因为后端同学和前端同学写的代码是不一样的, 原来做纯页面的功能测试, 包括性能测试, 接口这里你做的测试要比 Web 自动化更靠前一些, 让开发同学写好一部分接口, 一个模块一个模块提完全是 OK 的, 你们优先开发哪些接口, 我的测试代码, 然后可以一块调一块测, 同时也收获了开发同学对你的信任, 那么整个质量的推进过程他们就会和你配合的非常好, 而不是单纯的做一些比较表面的, 这就是接口, 在前面的一些工作, 比如文档的编写, 一定要督促开发同学去写, 比如说第一个版本没有, 把这个流程推进完之后, 你的自动化代码确实是帮助了他们, 开发同学 自己测自己的代码基本正向, 甚至包括架构层面的测试, 其实在整个, 开发同学在周全方面, 因为他知道自己是怎么实现的, 但是各种原因吧, 有的时候可能会懒, 所以说测试人员是有质量意识上的优势的, 就是不断提升自己的代码能力, 

### 7-2 接口测试和持续集成面试考点

这个侧重点更多是在思想层面, 这里涉及到的技术点并不难, 只要思想层面到位了, 这两个部分就能做好.

#### 真题及考点分析

> 你的接口自动化是如何做的?

第一反应是: 你的接口自动化是如何做的. 主要是想问一下接口自动化的落地过程以及并且接口自动化取得了怎样的收益, 接口自动化跟 web 自动化是两个概念, 落地难点, 接口自动化也涉及到代码维护的, 因为接口自动化参数的传递比 Web 自动化更稳定, 所以更注重接口自动化思想层面代码的一个方面, 接口自动化参数的传递比Web自动化更稳定. 

> 你常用的接口请求方式及区别?

常用的接口请求方式, 肯定知道里边传递的数据和方式. 所以可能技术方面也没什么太多好问的. 

> 你的持续集成是怎么做的?

那么这道题还可以引申出: 你是怎么样看持续集成的, 持续集成在整个应用程序的开发过程中, 也就是围绕整个项目周期它到底起到了什么作用, 具体是怎么落地的, 大部分都是借助工具来做, 细节方面就是工具使用上, 

关于一些更具体的面试题

### 7-3 接口自动化落地难点及回答的核心思想

上一小节中说了接口自动化落地的过程, 引导一下面试官, 我在本小结我在落地过程做中碰到了哪些问题, 我是如何解决的. 你讲清楚了, 贯穿了所有的问题要围绕着核心思想就是, 所有的问题都要围绕着你的价值来讲. 具体的技术点问题, 思想层面就要围绕, 是不是就会让他心动, 所以.

那么接口自动化落地难点有哪些?

* 接口文档的管理(创建与维护)

  作为一个写代码的工作者, 别人的代码没有注释, 别人不写文档, 自己也不愿意写注释. 这是所有写代码的人. 所以说接口文档创建和维护特别难, 或者说迫于上面的压力, 后面也不愿意维护的. 怎么样, 但是你也得会使用. 比如说word文档, 谁来维护啊, 是不是一个特别难的问题, 你是怎样来解决这个问题的, 具体我在项目里是怎样来做的呢, 提了一句这个文档怎么做, 假如说第一个文档, 高频次的与, 让你掌握整个,你要让开发同学,见到你对他们的帮助, 第一轮过去了后面开发同学见到这些也愿意跟你合作, 他做哪些工作会更利于你的一些工作. 如果你的第一, 后面这个文档的创建也就是顺理, 如果没有, 证明我们项目推进的问题, 我们公司, 但是敏捷这种模式下轻文档不是没有文档, 高效文档的重要性, 好的文档可以降低沟通的频次. 因为没有人愿意写是正常的, 但是你要主动推进这个事, 我相信在学习这门课的你们. 还有一点. 文档相关的属于你的推动能力的体现

* 多测试人员协同开发时的 case 维护

  见到的 case 维护绝大多数同学是采用 Excel 的方式. 很多时候都是存在自己电脑上, 很少有一个中央管理器, 或者像开发同学那样, 就导致 case 的维护, 每个人维护一个case, 具体 case 应该怎么维护呢, 放在 具体测试环境的数据库, 每个人修改、新增一些case的时候, 这个case是共享, 然后我们多个测试人员一块去开发, 我们的代码维护也是用 Git,

一个是外因一个是内因. 体现了你要站在一个更高的角度去看这个问题, 然后也体现了你一个沟通, 测试组内按照你的标准, 你要是, 说明你的协同能力非常强, 也是你的核心价值点所在, 这个 case 的维护. 存储在数据库中, 代码存储, Git 同时你也可以说你推进了测试团队成员技术上的成长, 那么你可以围绕, 一个方向是外因, 一个是内因, 体现了你, 也要提现价值和 你的产出, 围绕着这个思路去讲. 

### 7-4 接口自动化常见面试题

接口自动化面试真题的技术点并没有太多, 也就是那么几样, 也没有什么花样

> 常用的接口自动化数据传递方式及区别

这个是非要问接口自动化里面的面试题, 传递方式就是 GET 和 POST, 把 HTTP 协议和 get post 理解反了, http 是一种协议, 可以用get. 他们的区别: 两个角度来回答数据格式和数据传递位置  key-value 格式

我们怎样来传递呢, 我们见到的在URL上传递, 一个key 和 value, 数据在 URL 上, POST 跟在请求体里面, 一般我们最常见的格式就是 json, 你要理解什么样的格式是 json, 还有另外一种格式是 key-value, 当然如果你用一些接口测试. 数据格式和数据传递的方式. 

> 接口测试中常用的库

就是 HTTP 协议Requests和urllib库. 现在就 Requests 库用的是最多了, 也可以看他. post 请求也就是底下加点数据. 并没有接触过 

### 7-5 持续集成落地过程及面试重点

本小节来说一下 , 你的持续集成是怎么做的啊? 每个人都有不同的回答.

持续集成的具体技术就是 Jenkins, 什么是

持续集成: 就是把所有的模块自动化部署把所有整个的模块自动部署到, 然后提供服务这么一个过程.

在整个项目位于什么位置, 测试准入, 还没有部署到真正的环境上的时候, 比如说, 有开发环境, 有测试环境, 有生产环境, 

测试准入 

内部集成: 指部门内部, 比如我们有一个应用程序, 有可能是不同开发小组, 持续集成核心思想是优化整个项目流程提高我们的工作效率, 把我们的时间花在, 这种环境部署是可以自动化的, 那就来一个自动化部署. 如果, 那么你把它流程化了, 甚至, 这就是持续集成的意义, 这就可以跑一个, 还有性能基准测试, 还有就是不跑时间很长, 基准测试的, 部署到持续集成环境上, 环境可以是串行的, 比如说可以, 如果, 那么这个基准测试应该怎么做, 看看有没有大的逻辑问题, 再往下就是功能测试、性能测试, 这个, 标记了一句话全链路测试. 外部就是有可能不是我们部门的, 有可能是跨部门, 大数据是属于很底层的一套架构, 上面有很多, 这种情况指的是外部集成, 单独的一套, 这是, 只要想调, 上层的偏业务的同学, 要不然的, 万一在业务上或者说, 是不是就会产生一些逻辑问题, 所以说外部集成就很重要, 技术上, 如果你们公司有这种核心思想就是自动化, 同时也要有性能测试. 因为每一块数据的传输都有时间的, 那整个链路来说用户感知这个过程一共经历了多长时间, 这个过程就是全链路的, 如果你的业务交互, 那这个外部集成, 它也是非常重要. 那么你讲这个. 技术方面没有太多花样可以讲, 你持续集成做的再好, 如果. 

外部集成完了以后就是上线部署, 然后就是线上回归, 他们有自己的持续集成工具, 内部集成环境和外部集成环境, 你的价值大了, 也是评估. Web 自动化面试, 还有一点就是收益, 收益围绕着什么来讲. 持续集成如果讲好了, 那么, 希望能够结合你

## 第8章 一面-性能测试进阶面试考点-java性能调优

### 8-1 jvm性能测试面试题考查点

jvm面试真题及技术点考察

> 什么是内存溢出? 为什么会内存溢出?

> JVM 的内存区域是如何划分的

> JVM 是如何进行垃圾回收的

### 8-2 图解jvm内存区域划分

### 8-3 理解jvm中垃圾回收的原因

### 8-4 jvm垃圾收集算法

### 8-5 补充操作文档的说明

### 第9章 一面- MySQL数据库使用及数据库性能调优面试考点

### 9-1 面试真题及技术点分析

在这里拿出几道经常问别人的面试题:

> MySQL 中索引什么作用?

索引不是很简单么, 重点是为了查询速度变快, 有很多很多的技术点, 索引分, 在不同的存储引擎. 会以一条主线来.



> 如何分析一条查询 SQL 的效率?

在有一个关键字有一个执行计划, 但是它就可以分析出mysql的效率. 

> MySQL 的常用存储引擎有什么? 区别是什么?

innodb, MyISam. 这一道题也可以结合. 它的, 并且索引是如何工作的.

### 9-2 索引在不同引擎中的存储形式

MySQL 中索引是什么作用?

单独来说, 索引底层还隐藏了很多很多技术点.

什么是索引

索引的定义和创建的目的

索引是对数据库表中<u>一列或多列</u>的值进行排序的一种结构, 使用索引可**快速访问**数据库表中的特定信息.

索引的分类?

主键索引, 

区别和创建的方式

创建索引的目的就是加快检索表中数据的速度, 也就是查询数据的速度.

> 索引是越多越好么?

不是, 索引过多的创建, 会带来数据的写入的代价过高, 即减慢数据写入速度.

索引过多的创建为什么会影响写入速度

MyISAM引擎:

数据存储分为三个文件:

* Table.frm 存储表定义
* Table.MYD 存储表数据
* Table.MYI 存储表索引

InnoDB 引擎:

存储方式:

* 共享表空间
  * 一个表中数据可以横跨多个文件: 文件1 文件2 文件3…文件n
* 单独表空间
  * 文件1, 也是表1的数据
  * 文件2, 也是表2的数据
  * 文件n, 也是表n的数据

数据存储到 /var/lib/mysql

进入到mysql中, 

```shell
ls -alh tables*


ls -alh server*
```



### 9-3 不同引擎下索引是如何工作的

MyISAM 引擎

InnoDB 引擎

为什么MyISAM 的查询引擎比 InnoDB 的快?



### 9-4 MySQL常用引擎的特点和区别

#### MyISAM 引擎的特点

1. 在进行数据的备份、迁移、恢复等操作时, 非常容易. 只要对文件进行操作就可以.
2. MyISAM 只支持表锁, 没有行锁
3. MyISAM 不支持事务安全, 但每次读的操作是具有原子性的, 所以不必担心脏读等情况[^1] 

#### InnoDB 引擎的特点

1. 支持事务、回滚、崩溃修复, 所以对数据安全性较高的业务场景都选择了这个引擎
2. 支持行级锁, 行级锁的支持大大提高了数据库的并发操作能力.
3. 支持外键约束, 在MySQL中, 只有InnoDB支持外键, 在<u>范式设计</u>[^2]的原则下, 外键约束保证了数据的完整性.

操作几十个G的数据, 

### 9-5 SQL语句效率分析

如何进行 SQL 优化

执行计划: explain 

用法: explain <SQL 语句>

## 第10章 一面- Linux操作系统基本操作及系统性能监控面试考点



### 10-1 Linux操作命令面试真题及讲解

> 如何动态查看文件中你关心的内容, 比如error信息

tail -f {文件名称} | grep “关键字”

> 如何跨服务器拷贝你的文件?

scp

> 超大文件在跨服务器拷贝过程中, 经常断开, 你怎么解决的?

rsync 断点续传

> 文件查看常用命令有什么? 请讲述他们的区别?

tail, more, less, cat

> 如何去除文件中的重复行

cat data | sort | uniq

如果想要改文件内容

cat data | sort | uniq > data1

> 如何通过监控命令查看服务器的平均负载值

### 10-2 Linux 监控命令说明

`top` 命令

load average: 5分钟, 10分钟, 15分钟

`free` 命令

`vmstat` 命令

`iostat` 命令



## 第11章 二面-项目面试的核心考察点

### 11-1 项目面试真题

二面最重要的点就是突出自己的价值.

1. 你是如何保证项目质量的?

   项目质量最终决定了项目上线的时候 bug 的多与少, 这道题问的核心点在于: 项目的时间、人员、流程都是固定的, 在这些固定的流程里面我们应该做出哪些事情来保证项目质量,因为我们不能要求别人怎么做, 我们自己怎么做就是一个非常重要的考核因素. 考察的就是面试者如何在很多条件都不可控的情况下自己多做什么事情来保证最终的项目质量, 保证我们的软件有质有量的进行上线. 看看面试者能不能在项目里面主动去思考这些事情, 并主动去做这些事情.

2. 你是如何推进项目进度的?

   在实际的项目过程中大家都会面临一个问题: 眼看着马上上线了, 然后没有测试时间了. 如何能够按照最早既定的时间保证上线. 其实如果说是你遇到了刚才那种情况, 比如说明天上线今天才提测, 那你做什么都晚了. 这里的核心点在于预防, 你不要让所有的事情都堆积到后面,也不要让开发人员在开发项目的过程中你什么都不做只是等待他真正提交测试的时候才来做这些事. 这个时候就要看你在项目里面推进能力. 提前我们可以做一些什么事去保证我们后面的工作变得很顺利, 还有就是要是提前做了这些事,后面的测试就会变得很顺利, 不要等着项目真正提交到你手上了再去了解各种各样的事, 浪费很多很多时间.

3. 推进项目的过程中遇到了哪些问题

   既然上面讲述了推进项目里面表现出来我们对工作的积极性和热情, 那做这件事必然会引来一系列的问题, 这个问题我们是怎么解决的, 都遇到了哪些问题. 假设说即便没遇到问题, 你得说两个体现你价值的问题, 再说一下你是怎么推进的, 怎么解决的.

二面掌握住这些核心点, 能够比较突出你在整个项目里的价值.

### 11-2 你是如何保证项目质量的

回顾一下项目的流程

然后再进行单元测试. 保证项目的质量一定要从源头开始抓起. 立项的阶段开始写文档. 如果人家代码都写完了 保证项目质量的第一步就是要尽早了解项目的需求. 在开发人员编写代码的过程中可以写一些测试代码. 保证掌握的需求是第一手的不是很多人. 代码能力如何增强, 无非就就是学习. 

测试准入. 所有的测试人员会把测试都做好. 当开发人员把项目部署好之后开发就会调起 然后跑一下. 如果通不过. 保证开发人员提交过来的 而不是有可能跑都跑不通的项目. 如果有可能, 在自己的项目中测试准入. 放到持续集成的环境中.

测试准入跑完了以后, 就开始内部集成. 可以跑一下 Web 自动化, 接口自动化, 性能基准测试. 内部集成的代码. 尽量在开发人员. Web 自动化有一定难度, 如果前端人员没有写好. 但是接口自动化代码一定要提前写. 你可以提前 mock 一个环境. 就是刚才提到的立项在文档之初. 在架构设计

### 11-3 你是如何推进项目进度的

如果因为测试人员的, 我们如何去避免这些情况呢. 一般

第一件事是站会, 我开过高效的站会, 当然不一定是站会这种形式, 有一种手段或方法开发或测试他们的工作进度, 这样你就了解到整个项目的的进度, 

站会之后是在项目里面要分模块进行自动化测试. 每个模块是散开的, 当所有模块, 如果把测试再进行测试, 第一是bug的排查不好找, 导致. 首先其中一个开发人员就, 点对点的沟通, 发现 bug 了, 直接 提高测试效率. 只是当时, 如果再改起来也有问题, 

持续集成, 节省了项目部署的时间, 降低集成测试成本. 然后都改掉了, 持续集成它是包含运维、开发测试都包括在内的, 把它做好可以让, 避免一些不必要的时间浪费. 

多沟通, 你是提前知道或 你有可能做出相应的一些反应, 这样不好, 也不是. 第二个就是产品经理, 在一定程度上有需求的设计权, 你跟他多沟通就. 第三个就是跟项目经理多沟通. 项目经理主要推动项目进度. 你要, 先做到, 总有人去沟通, 沟通带来的另外的好处是提前评估意外的需求变更带来的风险. 一旦在, 同时给出一个解决方案是最好的, 你要让她评估, 以上就是对如何推进项目进度的见解

### 11-4 项目中遇到了哪些问题

一定不要说: 吐槽, 别人做的这不好那不好. 那应该说哪些?

分为内部问题和外部问题: 

内部问题: 

无自动化, 测试效率低: 发现项目, 要提高, 推进自动化的测试能力, 再往下讲具体是怎么做的. 

有自动化用例但维护不及时: 读取Excel里的数据然后,

​	推进用例以原始数据的形式存储在数据库中

​		每个人都要, 这些数据就共享了, 这些, 真正解决问题, 工作中别人干啥我干啥, 我发现问题, 最后一个阶段是我不仅可以, 真正去解决这个问题, 我都能达到. 这个也





### 11-5 为项目做了哪些贡献



## 第12章 三面-综合素质面试

### 12-1 综合素质面试的核心考查点

三面为什么有时候挂的莫名其妙?

#### 综合素质面试核心点剖析

* 性格

* 稳定性

  我要看你过去的一些工作经历, 是否是足够的时间长, 前两年, 员工的稳定性拿到台面上了. 这是任何一个公司

* 沟通能力

  其实也是一种语言表达能力, 随便聊一聊的过程中, 技术立足, 项目中沟通能力

* 团队协作能力

  在团队中你是什么样的角色, 

* 管理能力(个人及团队)

  个人管理能力属于你有没有良好的习惯, 一种是工作上的习惯: 有没有明确的计划, 每一步应该做什么, 生活中的管理能力, 

  团队管理能力也是一种协调能力. 如果他们愿意配合你, 这种管理能力就是非常不错的. 下面有一些人资历比你老.

* 目标感与责任感

  看似责任感很虚, 但是责任感又无所不在. 如果是一家中小型公司, 

  目标感就是你对未来是否有规划. 

人人都希望有这样一个员工, 你是否

#### 三面综合素质面试面试真题

* 业务能力(特定行业的业务知识)

* 团队中有人不服你怎么办?(管理岗必备)

* 未来的职业规划是什么?

  对自己是否有一个很好的管理能力

* 你认为你能够胜任这个工作的原因是什么?

  将自己的优点是什么, 跟这个岗位的匹配度是什么

* 为什么要离职

  一定要讲一个让人信服

* 团队中有工作需要加班, 你会如何处理

### 12-2 解决人际关系

#### 团队中有人不服你怎么办

首先分析一下对方, 一种是男人. 女人. 请她帮忙. 



### 12-3 职业规划问题核心点

#### 未来的职业规划是什么

##### 无休止的技术之路

要尽量和工作挂上钩, 要把自己锁一些

##### 尽自己最大的努力为团队、为公司的效能共享力量



### 12-4 为什么能够胜任这份工作

能够胜任这份工作的原因是什么

个人优势

* 持续的学习能力 -  丰富知识体系可为公司做更大的共享
* 乐观的态度 - 遇到困难优先去想解决办法, 而不是逃避
* 对工作的热情 - 在工作中能够找到自信与成就感

### 12-5 离职原因不可触碰的雷区

不可触碰的雷区

* 吐槽加班
* 吐槽公司和老板
* 吐槽团队
* 吐槽制度

### 12-6 聊聊加班的问题

* 首先表明态度

  我不介意加班, 

* 思考解决办法

  常态加班, 公司, 因为每个公司背后都有它自己的原因, 作为面试者,

* 提高工作效率

  哪些工作是重复劳动, 让它都自动化的处理. 项目组加班的情况

### 12-7 个人经典问题与总结

#### 你自己有什么缺点

##### 只讲技术方面, 比如知识的深度还不够, 源码阅读的比较少

##### 切记不要讲性格方面的缺点

#### 结婚&生子

##### 核心: 短时间内没有计划

#### 业余时间有什么爱好

##### 一定要是积极向上的爱好

##### 对新技术的探索

##### 同事聚会, 加强默契与了解

#### 再次总结三面的核心关键词

乐观

好学

积极

有责任

随和

风险

## 第13章 课程总结

### 13-1 课程总结

#### 面试核心流程回顾

一面: 技术

二面: 项目

三面: 综合素质

#### 职业技能树深入方向

#### 简历的核心点

##### 价值

##### 数字

除非你很好看, 否则不要轻易贴照片































































