# [Python学到什么程度可以面试工作？](https://www.zhihu.com/question/54513391)

>1.列出 5 个常用 Python 标准库？

os: 有关于操作系统的操作

json：关于 json 的操作

sys：有关于系统的一些操作

datetime：关于时间的操作

base64：base64 编码解码的操作

---

答案：

```python
import os			# 操作系统接口  示例：os.system('ls')
import sys			# 命令行参数	   示例：sys.path
import re			# 正则模块		示例：re.match('www', 'www.baidu.com')
import math			# 数学模块		示例：math.cos(math.pi / 3)
import time			# 日期模块		示例：time.sleep
import random		# 随机数模块	   示例：random.random()
import threading	# 线程模块		示例：threading.Thread(target=lambda a,b:a.append(b), args=([1,2], 3))
import multiprocessing	# 进程模块	示例：multiprocessing.Process(target=method, args=([1, 2], 3)) # pickle 模块不能序列化lambda，需要自定义函数
```

>2.Python 内建数据类型有哪些？

数值
    int
    long
    bool
str
list
tuple
dict
set

---

答案：

```python
# 数值型-- int、float、complex
# 布尔型-- bool
# 字符串-- str
# 列表-- list
# 元组-- tuple
# 字典-- dict
```

> 3.简述 with 方法打开处理文件帮我们做了什么？

不管打开文件或处理文件的过程中是否发生异常，with内置了一个finally 帮我们关闭文件

---

答案：

* with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭，线程中锁的自动获取和释放等。

* with 语句即“上下文管理器”，在程序中用来表示代码执行过程中所处的前后环境

	上下文管理器：含有 `__enter__` 和 `__exit_` 方法的对象就是上下文管理器

* `__enter__`：在执行语句之前，首先执行该方法，通常返回一个实例对象，如果 with 语句有 as 目标，则将对象赋值给 as 目标

* `__exit__`：执行语句结束后，自动调用 `__exit__` 方法，用户释放资源，若此方法返回布尔值 True，程序会忽略异常

* 使用环境： 文件读写、线程锁的自动释放等

> 4.列出 Python 中可变数据类型和不可变数据类型，为什么？

可变数据类型：list, dict, set

不可变数据类型：数值，布尔，元组，字符串

---

答案：

```python
# 不可变数据类型： 即数据被创建之后，数据的值将不再发生改变，有数值、字符、元组类型
# 可变数据类型： 数据被创建之后，数据的值可以发生变化，有列表、字典、集合类型
```

> 5.Python 获取当前日期？

```python
import datetime
print(datetime.datetime.now())
```

> 6.统计字符串每个单词出现的次数

这个题对题意的理解一定要正确，不能想错，不是统计单个字符的出现次数，而是单词的出现次数

```python
# 方法一
def word_amount(sentence):
    """计算句子的单词数量
    计算句子中的单词数量，并返回结果字典
    :param sentence: 句子对象
    :return: 计算结果字典
    """
    # 使用 split 方法切割句子
    split_list = sentence.split()
    dict_result = {}
    # 遍历列表，判断每个值是否在新字典的键中，如果在则键值加一，不存在设为1
    for word_name in split_list:
        if word_name not in dict_result.keys():
            dict_result[word_name] = 1
        else:
            dict_result[word_name] += 1
    return dict_result

if __name__ == '__main__':
    sentence = "I can because i think i can"
    dict_result = word_amount(sentence)
    print(dict_result)
    
# 方法二
# count() 用来统计字符串中 word 出现的次数，count(sub, start=None, end=None) 有三个参数，
# 依次是待统计字符，字符索引开头，索引结尾
sentence = "I can because i think i can"
result = {word: sentence.split().count(word) for word in set(sentence.split())}
print(result)

# 方法三
from collections import Counter
sentence = "I can because i think i can"
# Counter 是一个简单的计数器，可以数组中统计字符出现的个数
counts = Counter(sentence.split())
print(counts)  # Counter({'can': 2, 'i': 2, 'I': 1, 'because': 1, 'think': 1})
```

> 7.用 python 删除文件和用 linux 命令删除文件方法

python 删除文件： os.sys.remove()

linux 删除文件： rm -rf {文件名}

---

答案：

```python
#  Python 方法
import os
os.remove("demo.txt")

# Linux 方法
rm demo.txt
```

> 8.写一段自定义异常代码

```python
try:
    pass
except:
    pass
else:
    pass
finally:
    pass
```

---

答案：

```python
def judge_value(num_value):
    """ 自定义异常函数
    自定义异常函数，用于抛出大于一定值的异常
    :param num_value：用户判断的值
    :return：异常信息
    """
    if num_value > 10:
        # raise 用于抛出自定义异常，格式为 raise 异常类型（异常注明）
        # 一旦触发则不再执行 raise 后面的代码
        raise ValueError("数量不能大于10")
    else:
        return "200"
    
if __name__ == '__main__':
    judge_value(10)
```

> 9.举例说明异常模块中 `try` `except` `else` `finally` 的相关意义

不知道应该怎么写。。。就直接看答案吧

```python
def read_filedata(file_name):
    """读取文件数据
    读取指定文件中的所有数据，返回数据或异常信息
    :param file_name: 文件路径
    :return: 文件数据或异常信息
    """
    file_obj = ""
    try:
        # 需要检测的异常代码片段
        file_obj = open(file_name, "r")
        result_data = file_obj.read()
    except IOError, e:
        # 发生“IOError”异常进行处理的代码片段
        file_obj = "文件不存在" + str(e)
    else:
        # 没有引发 IOError 异常时执行的代码片段
        # 返回读取到的数据
        return result_data
   	finally:
        # 不管有没有引发错误都会执行的代码片段
        if isinstance(file_obj, str):
            return file_obj
        elif isinstance(file_obj, file):
            file_obj.close()
        else:
            return "未知错误，请检查您的代码"

if __name__ == '__main__':
    result = read_filedata("abc.txt")
    print(result)
```

> 10.遇到 bug 如何处理

不知道如何回答, 直接查看答案:

* 首先查看报错信息, 根据报错信息找到相应代码, 通常一般的数据结构或者算法错误只要找到报错代码就可以顺利解决
* 如果遇到暂时不能解决的错误先不要慌, 我们可以使用编译器的 Debug 模式或者自己在代码中加入断点进行排查
* 如果依然不能解决 bug, 我们可以拷贝报错信息, 在搜索引擎中进行搜索
* 没有人写代码不出 bug, 如果你在一个 bug 上耗费时间超过半小时, 可以与其他同事探讨
* 另辟蹊径: 方法总比困难多, 在进行快速开发时, 我们应该优先实现功能而不是拘泥于运行效率, 所以遇到一些暂时不能解决的 bug 可以考虑另外的实现方法

### 语言特性

> 1.谈谈对 Python 和其他语言的区别

Python 是一门语法简洁优美，功能强大无比，应用领域非常广泛，具有强大完备的第三方库的一门强类型的动态，可移植，可扩展，可嵌入的解释型编程语言。

Python 为强类型语言这一点一直有争议，还有人说 Python 之父说过是“弱类型”，这里进行一个补充，回答时只要合理解释即可：

如果语言经常隐式地转换变量的类型，那么这个语言就是弱类型语言，如果很少会这样做，那就是强类型语言。 Python 很少会隐式地转换变量的类型，所以 Python 是强类型的语言。

解释型：解释型语言使用解释器将源码逐行解释成机器码并立即执行，不会进行整体性的编译和链接处理，相当于把编译语言中的编译和解释混合到一起同时完成。

优点：跨平台容易，只需要提供特定平台的解释器

缺点：运行效率较低，因为每次执行相当于都要进行一次编译

简洁优雅：省略了各种大括号和分号，还有一些关键字，类型说明（自省）；

面向对象： Python 和 C++、Java 一样都是面向对象编程语言

跨平台：简单搭建 Python 解释器可以在大部分平台运行。

Python 和 Java 相比：

Python 是动态类型语言，而 Java 是静态类型语言

动态类型语言不需要事先声明变量的类型，而且变量的数据类型可以被修改

静态类型语言需要事先声明，并且不能修改

Python 和 C 相比：

对于使用：

Python 的类库齐全并且使用简介，很少代码实现的功能用C可能要很复杂

对于速度：

Python 的运行速度相较于C，绝对是很慢了，Python 的 CPython 解释器是 C 语言编写的。

> 2.简述解释型和编译型编程语言

参见上一条

> 3.Python 的解释器种类以及相关特点？

CPython

IPython

PyPy

Jython

IronPython

4.说说你知道的Python3 和 Python2 之间的区别？
5.Python3 和 Python2 中 int 和 long 区别？
6.xrange 和 range 的区别？

### 编码规范

>  7.什么是 PEP8?

PEP 是 Python Enhancement Proposal 的缩写, 翻译过来就是 Python 增强建议书.

PEP8 简单说就是一种编码规范, 是为了让代码“更好看”, 更容易被阅读

> 8.了解 Python 之禅么？

```python
import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
优美胜于丑陋(Python 以编写优美的代码为目标)
Explicit is better than implicit.
明了胜于晦涩(优美的代码应当是明了的, 命名规范, 风格相似)
Simple is better than complex.
简洁胜于复杂(优美的代码应当是简洁的, 不要有复杂的内部实现)
Complex is better than complicated.
复杂胜于凌乱(如果复杂不可避免, 那代码间也不能有难懂的关系, 要保持接口简洁)
Flat is better than nested.
扁平胜于嵌套(优美的代码应当是扁平的, 不能有太多的嵌套)
Sparse is better than dense.
间隔胜于紧凑(优美的代码有适当的间隔, 不要奢望一行代码解决问题)
Readability counts.
可读性很重要(优美的代码是可读的)
Special cases aren't special enough to break the rules.
Although practicality beats purity.
即便假借特例的实用性之名, 也不可违背这些规则(这些规则至高无上)
Errors should never pass silently.
Unless explicitly silenced.
不要包容所有错误, 除非你确定需要这样做(精准地捕获异常, 不写 except: pass 风格的代码)
In the face of ambiguity, refuse the temptation to guess.
当存在多种可能, 不要尝试去猜测
There should be one -- and preferably only one -- obvious way to do it.
而是尽量找一种, 最好是唯一一种明显的解决方案(如果不确定, 就用穷举法)
Although that way may not be obvious at first unless you're Dutch.
虽然这并不容易, 因为你不是 Python 之父(这里的 Dutch 指 Guido)
Now is better than never.
Although never is often better than *right* now.
做也许好过不错, 但不假思索就动手还不如不做(动手之前要细思量)
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
如果你无法向人描述你的方案, 那肯定不是一个好方案; 反之亦然(方案测评标准)
Namespaces are one honking great idea -- let's do more of those!
命名空间是一种绝妙的理念, 我们应当多加利用(倡导与号召)
```

> 9.了解 docstring 么？

`DocStrings` 文档字符串是一个重要工具, 用于解释文档程序, 帮助你的程序文档更加简单易懂.

我们可以在函数体的第一行使用一对三个单引号`'''`或者一堆三个引号`"""` 来定义文档字符串.

你可以使用 `__doc__`调用函数中的文档字符串属性.

`DocStrings` 文档字符串使用惯例: 它的首行简述函数功能, 第二行空行, 第三行为函数的具体描述.

```python
def create_iterator(list_param):
    """创建迭代器
    
    使用生成器推导式创建一个迭代器, 并返回迭代器
    :param list_param: 迭代对象
    :return: 迭代器
    """
    # 将列表推导式的“[]”改为“()”即为生成器推导式, 众所周知, 生成器返回一个迭代器对象
    return (value for value in list_param)


if __name__ == '__main__':
    # 遍历迭代器
    for i in create_iterator([1, 2, 3]):
        print(i)
    # 使用__doc__ 输出函数中的文档字符串属性
    print(create_iterator.__doc__)
    # 使用__dir__输出函数中的所有属性和方法
    print(create_iterator.__dir__())
```

补充:

类的函数称为方法(method), 模块里的函数称为函数(function)

每一个包, 模块, 类, 函数, 方法都应该包含文档, 包括类的 `__init__` 方法

包的文档写在`__init___.py`文件中

文档有单行文档和多行文档

单行文档:

不要重复函数的声明语句, 例如: function(a, b) -> list

指明做什么和返回什么, 例如: Do X and return a list.

使用三引号, 方便换行

多行文档

如果模块是一个脚本, 也就是单文件程序, 模块的文档应该写明脚本的使用方法

模块的文档需要写明包含的类, 异常, 函数

如果是包, 在`__init__.py`中写明包里面包含的模块, 子包

如果是函数或类方法, 应该写明函数或方法的作用, 参数, 返回, 副作用, 异常和调用的限制等

如果是类, 写明类的行为, 和实例参数, 构造方法写在`__init__`中

使用三引号, 而且两个三引号都应该单独成行.

> 10.了解类型注解么？

首先, Python 是一种动态语言, 变量和函数的参数是不区分类型的.

Python 解释器会在运行的时候动态判断变量和参数的类型, 这样的好处是编写代码速度很快, 很灵活, 但是坏处也很明显, 不好维护, 可能代码写过一段时间重新看就很难理解了, 因为那些变量、参数、函数返回值的类型, 全都忘记了.

在阅读别人的代码时, 无法看出变量或参数的类型, 这样对工作效率带来很大影响.

因此, 在 Python3 中新添加了“类型注解”特性, 可以给参数、函数返回值和变量的类型加上注解, 该注解仅仅是注释而已, 对代码运行不会产生任何影响, 真正的变量类型还是由 Python 解释器决定, 你所做的只是提高代码可读性, 并不会像静态语言中变量类型定义后就无法修改(强转除外)

```python
def list_to_str(param_list: list, connect_str: str=" ") -> str:
    """列表转字符串
    
    使用 join 方法将列表转为字符串并返回
    :param param_list: 列表
    :param connect_str: 需要插入的字符, 默认为一个空格
    :return : 转换成功的字符串
    """
    demo_tuple: tuple = (1, 2)
    demo_dict: dict = {"1": 1}
    return connect_str.join(param_list)


if __name__ == '__main__':
    result = list_to_str(["Hello", "world"])
    print(result)
```

以上代码可以看出, 一般变量和函数参数注解格式为“参数: 类型“, 默认参数是在类型的后面加“=默认值”, 函数的返回值注解格式为“->类型:”, 函数的冒号在注解后方

Python 提供了一个工具方便我们测试类型注解的正确性

```shell
pip install mypy
```

使用方法:

```shell
mypy demo.py
```

若无错误则无输出, 反之会输出如下:

```shell
D:\code\web\flaskweb>mypy demo.py
demo.py:12: error: Incompatible return value type (got "str", expected "int")
```

> 11.例举你知道 Python 对象的命名规范，例如方法或者类等

* 变量命名: 字母数字下划线, 不能以数字开头

  * 单下划线开头变量

    单下划线开头的变量表明是一个受保护(protected)的变量, 原则上不允许直接访问, 但外部类还是可以访问到这个变量.

    这只是程序员之间的一个约定, 用于警告说明这是一个私有变量, 外部类不要去访问它.

  * 双下划线开头变量

    双下划线开头的, 表示是私有类型(private)的变量. 只能是允许这个类本身进行访问, 连子类也不可以.

    以双下划线开头并且以双下划线结尾的, 是内置变量

    内置变量是可以直接访问的, 不是 private 变量, 如 `__init__`, `__import__`或者是 `__file__`

    **<u>不要自己定义内置变量</u>**
    
  * xxx_, 单下划线结尾的变量一般只是为了避免与 Python 关键字的命名冲突
  
    * USER_CONSTANT, 大写加下划线, 对于不会发生改变的全局变量, 使用大写加下划线
  
* 函数和方法(类中叫做方法, 模块中称作函数)命名:

  总体而言应该使用小写和下划线, 如: `create_user()`

  * 私有方法: 小写和一个前导下划线, 如 def _create_user(self)

    一般函数不要使用两个前导下划线(当遇到两个前导下划线时, Python 的名称改编特定将发挥作用)

  * 特殊方法

    小写和两个前导下划线, 两个后置下划线 `def __init__(self)`, 这种风格只应用于特殊函数, 比如操作符重载等

  * 函数参数

    小写和下划线, 缺省值等符号两边无空格 `def __init__(self, param=None)`

    不要滥用 *args 和 **kwargs, 可能会破坏函数的健壮性

* 类命名

  类总是使用驼峰格式命名, 即所有单词首字母大写其余字母小写

  如: Class CreateUser():

  类名应该简明, 精确, 并足以从中理解类所完成的工作

  常见的一个方法是使用表示其类型或者特性的后缀, 例如: SQLEngine, MimeTypes

  对于基类而言, 可以使用一个 Base 或者 Abstract 前缀

* 包和模块

  小写字母、数字和下划线

> 12.Python 中的注释有几种？

单行注释以“#”开头

多行注释使用三个单引号或者双引号

单引号和双引号混用, 使用一种引号后其注释中的所有引号应该使用另一种

```python
# 单行注释
"""
'双引号' 中使用 '单引号'
"""

'''
"单引号" 中使用 "双引号"
'''
```

> 13.如何优雅的给一个函数加注释？

见第9题

> 14.如何给变量加注释？

变量注释使用行内注释, 根据 PEP8 规范应该在代码后至少有两个空格, 注释由# 和一个空格开始:

```python
user_name = "Robin"		# 用户姓名
user_age = 26			# 用户年龄
user_gender = 1			# 用户性别, 男为1, 女为0
```

有代码洁癖的同学可以保持注释的对齐, 但一行文本不宜超过79个字符(PEP8规范)

> 15.Python 代码缩进中是否支持 Tab 键和空格混用。

Python 是一门用空格缩紧来区分代码层次的语言, 其实 Python 并没有强制要求你用 Tab 缩进或者用空格缩进, 甚至空格按几个都没有强制要求(但在 PEP8 中建议来使用4个空格作为缩进)

但是不能混用 Tab 和空格

Python 中不提倡使用 Tab 缩进

不同编辑器对于 Tab 的解释是不同的, 有的编辑器 Tab 是4个字符宽, 有的 8 个字符宽

如果有的地方用 Tab, 有的地方用空格, 在不同的地方, 原本对齐的代码就可能会不对齐

> 16.是否可以在一句 import 中导入多个库?

可以在一个 import 中导入多个库, 但是一般我们不这样做, 原因有以下几点

> 更易于阅读
>
> 更易于搜索
>
> 更易于编辑
>
> 多行 import 更易于维护

另外, 导入多个模块语句最好以下面方式书写, 使用空行将其分割

* Python 标准库模块
* Python 第三方模块
* 自定义模块

有的程序员喜欢这样导入模块

`from socket import *`

这样写的好处就是不需要我们一个个列出“socket”需要的方法, 但是这样引入的弊端如下

* 占用更多的内存空间, 不必要的方法或者类可能会进行初始化
* 代码可读性差, 模块内部突然冒出一个没有见过也没有归属的方法, 很头疼

> 17.在给 Py 文件命名的时候需要注意什么?

在为 Python 文件命名时, 我们需要注意:

* 不能以 Python 中的关键字命名
* 不能以标准库或常用第三方库命名, 除非你想重写这些库
* 不能用除数字字母下划线之外的字符命名, 注意不要使用中文命名任何路径和可执行文件
* 数字不能作为开头

> 18.例举几个规范 Python 代码风格的工具

Pylint, Black, Autopep8, flake8

### 数据类型

#### 字符串

19.列举 Python 中的基本数据类型？

20.如何区别可变数据类型和不可变数据类型

> 21.将"hello world"转换为首字母大写"Hello World"

```python
def first_capital(change_sentence: str)->str:
    """句子所有单词首字母大写
    
    将句子的首字母大写并返回
    :param change_sentence: 需要转换的句子
    :return: 返回转换后的字符串
    """
    # 将句子使用split切割为list列表
    split_list = change_sententce.split()
    # 遍历列表长度值
    for i in range(len(split_list)):
        # 使用capitalize() 函数将每个单词首字母转为大写
        split_list[i] = split_list[i].capitalize()
        # 也可以使用 upper() 方法, upper() 可以把所有的小写字母转为大写, lower() 是转小写
        # split_list[i] = split_list[i][0].upper() + split_list[i][1:]
    # 使用 join 将列表转为字符串
    split_list = " ".join(split_list)
    return split_list

if __name__ == '__main__':
    change_sentence = "hello world"
    print(first_capital(change_sentence))
    # 也可以使用匿名函数、列表推导式和map方法一行写出以上代码
    print(" ".join(list(map(lambda word: word.capitalize(), change_sentence.split()))))
```

> 22.如何检测字符串中只含有数字?

`isdigit()` 方法检测字符串是否只由数字组成

```python
demo_str = "123456"
print(demo_str.isdigit())						# 输出 True
demo_str = "this is string example...wow!!!"
print(demo_str.isdigit())						# 输出 False
```

> 23.将字符串"ilovechina"进行反转

```python
from functools import reduce

# 第一种方法, 使用字符串切片
demo_str = "ilovechina"
print(demo_str[::-1])

# 第二种方法, 使用列表的 reverse 方法
list_str = list(demo_str)
list_str.reverse()
print("".join(list_str))

# 第三种方法: reduce 累加方法
# 具体步骤是将前两个字母初始化添加到 lambda 函数中, 得到的结果在与下一个字母做累加直到结束
# 第一次: l + i = li
# 第二次: o + li = oli
# 第三次: v + oli = voli
# ...
# 第九次: a + nihcevoli = anihcevoli
print(reduce(lambda x, y: y+x, demo_str))

# 使用栈, 先进后出
def stack_demo(demo_str):
    # 模拟全部入栈
    list_stack = list(demo_str)
    result_str = ""
    while len(list_stack) > 0:
        # 模拟出栈
        result_str += list_stack.pop()
    return result_str

print(stack_demo(demo_str))
```

> 24.Python 中的字符串格式化方式你知道哪些？

没有答案...

有 %, .format() 还有 f-string

> 25.有一个字符串开头和末尾都有空格，比如“ adabdw ”,要求写一个函数把这个字符串的前后空格都去掉。



> 26.获取字符串”123456“最后的两个字符。



> 27.一个编码为 GBK 的字符串 S，要将其转成 UTF-8 编码的字符串，应如何操作？



> 28.(1)s="info：xiaoZhang 33 shandong"，用正则切分字符串输出['info', 'xiaoZhang', '33', 'shandong'](2) a = "你好 中国 "，去除多余空格只留一个空格。



> 29.(1)怎样将字符串转换为小写 
>
> ​	(2)单引号、双引号、三引号的区别？

(1) 使用 lower() 方法

(2) 在Python 中我们都知道单引号和双引号都可以用来表示一个字符串, 比如:

```python
str1 = 'python'
str2 = "python"
```

str1和str2是没有任何区别的, 但是如果遇到需要转义字符的情况, 来看单引号和双引号的版本



#### 列表

> 30.已知 AList = [1,2,3,1,2],对 AList 列表元素去重，写出具体过程。



> 31.如何实现 "1,2,3" 变成 ["1","2","3"]



> 32.给定两个 list，A 和 B，找出相同元素和不同元素



> 33.[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]



> 34.合并列表[1,5,7,9]和[2,2,6,8]



> 35.如何打乱一个列表的元素？



#### 字典

> 36.字典操作中 del 和 pop 有什么区别



> 37.按照字典的内的年龄排序

```python
d1 = [
    {'name': 'alice', 'age': 38},
    {'name': 'bob', 'age': 18},
    {'name': 'Carl', 'age': 28}
]
```



> 38.请合并下面两个字典 a = {"A":1,"B":2},b = {"C":3,"D":4}



> 39.如何使用生成式的方式生成一个字典，写一段功能代码。



> 40.如何把元组("a","b")和元组(1,2)，变为字典{"a":1,"b":2}



### 综合

> 41.Python 常用的数据结构的类型及其特性？
>
> ```python
> A: {1:0, 2:0, 3:0}
> B: {"a":0, "b":0, "c":0}
> C: {(1,2):0, (2,3):0}
> D: {[1,2]:0, [2,3]:0}
> ```

(这道题应该是问的字典的key的特性吧)

字典中的键是不可变类型, 可变类型 list 和 dict 不能作为字典键

一个对象能不能作为字典的 key, 就取决于其有没有`__hash__`方法

> 42.如何交换字典 {"A"：1,"B"：2}的键和值？



> 43.Python 里面如何实现 tuple 和 list 的转换？



> 44.我们知道对于列表可以使用切片操作进行部分元素的选择，那么如何对生成器类型的对象实现相同的功能呢？



> 45.请将[i for i in range(3)]改成生成器



> 46.a="hello"和 b="你好"编码成 bytes 类型



> 47.下面的代码输出结果是什么？
>
> ```python
> a = (1, 2, 3, [4, 5, 6, 7], 8)
> a[2] = 2		# TypeError: 'tuple' object does not support item assignment
> ```

元组是不可变类型, 因此不能修改元组内的值

`a[2] = 2` 使得元组中对索引值为“2”的元素进行了修改, 内存 id 发生了变化.

> 48.下面的代码输出的结果是什么?
>
> ```python
> a = (1, 2, 3, [4, 5, 6, 7], 8)
> a[3][0] = 2
> ```



### 操作类题目

> 49.Python 交换两个变量的值

```python
>>> a = 1
>>> b = 2
>>> a, b = b, a
2, 1
```

---

原答案：

```python
a, b = b, a
```

> 50.在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的作用

`read` 是一次性把文件中所有内容都读到内存

`readline`是读取文件中的第一行

`readlines` 是按行读取文件中的内容

---

原答案：

`read`：读取整个文件

`readline`：读取下一行，使用生成器方法

`readlines`：读取整个文件到一个迭代器以供我们遍历

> 51.json 序列化时，可以处理的数据类型有哪些？如何定制支持 datetime 类型？

json 序列化时，可以处理列表、字典、字符、数值、布尔和None

```python
from datetime import datetime
import json
from json import JSONEncoder

class DatetimeEncoder(JSONEncoder):
    """扩展 JSONEncoder 类中的 default 方法
    
    判断传入的类型是否是 datetime 类型，如果是则转为
    str 字符，否则不是返回父类的值
    """
    def fault(self, o):
        is isinstance(o, datetime):
            return o.strftime('%Y-%m-%d %H:%M:%S')
        else:
            return super(DatetimeEncoder, self).default(o)
        
if __name__ == '__main__':
    dict_demo = {'name': 'alex', 'data': datetime.now()}
    print(json.dumps(dict_demo, cls=DatetimeEncoder))
```

> 52.json 序列化时，默认遇到中文会转换成 unicode，如果想要保留中文怎么办？

```python
import json

dict_demo = {"name": "旭东"}
# 使用 dumps 的默认参数 ensure_ascii
print(json.dumps(dict_demo, ensure_ascii=False))
```



> 53.有两个磁盘文件 A 和 B，各存放一行字母，要求把这两个文件中的信息合并(按字母顺序排列)，输出到一个新文件 C 中。

```python
with open("A") as f1:
    str_a = f1.readline()
with open("B") as f2:
    str_b = f2.readline()
str_c = str_a + str_b
with open("C", "w") as f3:
    f.write("".join(sorted(str_c)))
```

---

原答案：

```python
def read_file(file_name):
    """读文件
    
    读取文件并返回文件数据
    :param file_name: 文件名
    :return: 文件的所有数据
    """
    with open(file_name, "r") as f:
        return f.read()
    
def write_file(file_name, file_data):
    """写文件
    
    将数据写入到指定文件中
    :param file_name：文件名
    :param file_data：需要写入的数据
    :return:
    """
    with open(file_name, "w") as f:
        f.write(file_data)
        
def letter_sort(letter_str, reverse_flag=False):
    """字母排序
    
    使用sorted排序算法
    :param letter_str：排序字母字符串
    :param reverse_flag: 排序顺序，False为正序，True为反序
    :return：排序后的新字符串
    """
    return "".join(sorted(letter_str, reverse=reverse_flag))

if __name__ == '__main__':
    test1_data = read_file("test1.txt")
    test2_data = read_file("test2.txt")
    new_data = letter_sort(test1_data + test2_data)
    write_file("new.txt", new_data)
```



> 54.如果当前的日期为 20190530，要求写一个函数输出 N 天后的日期，(比如 N 为 2，则输出 20190601)。

```python
from datetime import datetime
from datetime import timedelta


def date_calc(now_date, offset):
    """获取日期函数
    
    获取几天前或者几天后的日期
    :param now_date: 当前日期
    :param offset: 日期偏移量,负数为前
    :return: 结果日期
    """
    # 格式转换
    now_date = datetime.strptime(now_date, "%Y%m%d").date()
    # 计算偏移
    offset_date = timedelta(days=offset)
    return (now_date + offset_date).strftime("%Y%m%d")


if __name__ == '__main__':
    result_day = date_calc("20190530", 30)
    print(result_day)
```



> 55.写一个函数，接收整数参数 n，返回一个函数，函数的功能是把函数的参数和 n 相乘并把结果返回。



> 56.下面代码会存在什么问题，如何改进？
>
> ```python
> def strappend(num):
>     str = 'first'
>     for i in range(num):
>         str += str(i)
>     return str
> ```





> 57.一行代码输出 1-100 之间的所有偶数。



> 58.with 语句的作用，写一段代码？



> 59.python 字典和 json 字符串相互转化方法



> 60.请写一个 Python 逻辑，计算一个文件中的大写字母数量



> 61. 请写一段 Python连接 Mongo 数据库，然后的查询代码。



> 62.说一说 Redis 的基本类型。



> 63. 请写一段 Python连接 Redis 数据库的代码。



> 64. 请写一段 Python 连接 MySQL 数据库的代码。

```python
import pymysql

conn = pymysql.connect(host="192.168.1.1",
                       port=3306,
                       username="admin",
                       password="123456",
                       database="test",
                       charset="utf8")
cur = conn.cursor()
sql = "select * from table_name where arg='xxxx'"
cur.execute(sql)
cur.close()
conn.commit()  # 应该是先提交再关闭游标和连接
```

---

原答案：

```python
import pymysql

# 打开数据库连接
db = pymysql.connect("localhost", "testuser", "test123", "TESTDB", charset="utf8")

# 使用cursor() 方法获取操作游标
cursor = db.cursor()

# 使用 execute 方法执行 SQL 语句
cursor.execute("SELECT VERSION()")

# 使用 fetchone() 方法获取一条数据
data = cursor.fetchone()

# 关闭数据库连接
db.close()
```

> 65.了解 Redis 的事务么？

> 66.了解数据库的三范式么？

通俗解释

1. 属性不可分割：字段不能再分割，如“年级班级”可以分割为“年级”和“班级”两个字段
2. 唯一主键：一张表中需要有一个唯一主键用来区分每行数据，如“学生学号”
3. 消除冗余和传递依赖：不同表中不能存在重复的字段和数据，如“学生”表中的“院系”字段和“班级”表中的“院系”字段，我们可以关联两张表的字段而无需在“学生”表中再加一个“院系”

> 67.了解分布式锁么？

> 68.用 Python 实现一个 Reids 的分布式锁的功能。

> 69.写一段 Python 使用 Mongo 数据库创建索引的代码。



### 高级特性

> 70.函数装饰器有什么作用？请列举说明？

装饰器主要是在不修改代码前提下进行功能的扩展, 满足面向对象的“开闭原则”.

应用场景:

1. 引入日志
2. 函数执行时间统计
3. 执行函数前预备处理
4. 执行函数后清理功能
5. 权限校验等场景
6. 缓存
7. 事务处理

> 71.Python 垃圾回收机制？
> 72.魔法函数 `__call__`怎么使用?

`__call__`允许一个类的实例像函数一样被调用

```python
class Entity:
    def __init__(self, size, x, y):
        self.x, self.y = x, y
        self.size = size
        
    def __call__(self, x, y):
        # 改变实例属性
        self.x, self.y = x, y
        
if __name__ == '__main__':
    # 创建实例
    demo_obj = Entity(1, 2, 3)
    # 实例可以像函数那样执行, 并传入x y 值, 修改对象的x,y
    demo_obj(4, 5)
```

> 73.如何判断一个对象是函数还是方法？

在类外声明 `def` 为函数

类中声明 `def`: 使用类调用为函数, 使用实例话对象调用为方法

可以使用 `isinstance()` 判断.

```python
from types import FunctionType
from types import MethodType


class DemoClass:
    def __init__(self):
        pass
    
    def run_method(self):
        pass
    
def demo_func():
    pass


if __name__ == '__main__':
    demo_obj = DemoClass()
    print(demo_obj.run_method)
    # out:<bound method DemoClass.run_method of <__main__.DemoClass object at 0x000..>>
    print(demo_func)
    # out:<function demo_func at 0x000000000248C1E0>
    print(DemoClass.run_method)
    # <function DemoClass.run_method at 0x0000000002924400>
    print(isinstance(demo_obj.run_method, FunctionType))	# False
    print(isinstance(demo_obj.run_method, MethodType))		# True
```

> 74.`@classmethod` 和`@staticmethod` 用法和区别

`@classmethod` 是类方法: 访问和修改类属性, 进行类相关的操作, 通过类或实例对象调用,需要传递 `cls`类对象为参数

`@staticmethod` 是静态方法: 不访问类属性和实例属性, 通过类或实例调用,相当于一个普通函数

> 75.Python 中的接口如何实现？

类定义接口、函数定义接口

> 76.Python 中的反射了解么?

计算机中的反射, 是在运行的时候来自我检查,并对内部成员进行操作. 就是说这个变量的类型可以动态的改变, 在运行的时候确定它的作用.

在 Python 中, 能够通过一个对象, 找出其 type、class、attribute 或 method 的能力,称为反射或自省.

具有反射能力的函数有 `type()`, `isinstance()`, `callable()`, `dir()`, `getattr()` 等.什么是 PEP8?

> 77.`metaclass` 作用？以及应用场景？



> 78.`hasattr()` `getattr()` `setattr()`的用法

这三种方法用于为对象属性的存在判断、获取和添加修改, 简言之就是对象属性的“增、改、查”.

1. `hasattr(object, name)`: 判断对象是否存在 `name` 属性

   ```python
   class A:
       name = 'python'
       def func(self):
           return 'A类的方法func()'
   
       
   if __name__ == '__main__':
       print(hasattr(A, 'name'))		# True
       print(hasattr(A, 'age'))		# False
   ```

   

2. `getattr(object, name[, default])`: 获取`object`对象`name`属性的值, 若没有`name`属性, 则返回`default`值

   ```python
   class A:
       name = 'python'
       def func(self):
           return 'Hello world'
       
   
   if __name__ == '__main__':
       print(getattr(A, "name"))		# "python"
       print(getattr(A, "age"))		# Error: class A has no attribute 'age'
       print(getattr(A, "age", 18))	# 18
       print(getattr(A, "func"))		# <unbound method A.func>
       print(getattr(A(), "func"))()	# 'Hello world', 获取到的方法需要实力化后才能调用,类方法则不需要
   ```

   

3. `setattr(object, name, value)`给`object`对象的`name`属性赋值`value`, 如果对象原本存在给定的属性`name`, 则`setattr`会更改属性的值为给定的`value`, 如果不存在属性`name`, 会在对象中创建属性并赋值`value`

   ```python
   class A:
       name = 'python'
       def func(self):
           return 'Hello world'
       
   if __name__ == '__main__':
       setattr(A, 'name', 'java')
       print(getattr(A, 'name'))		# java
       setattr(A, 'age', 20)
       print(getattr(A, 'age'))		# 20
   ```

> 79.请列举你知道的 Python 的魔法方法及用途。

在Python 中, 所有以“_ _”双下划线包起来的方法称为“魔法方法”

魔法方法是 Python 解释器自动给出默认的, 因此除非需要改变其内部功能, 其他时刻使用默认魔法方法.

最常用的三个: `__init__`, `__new__`, `__del__`

`__new__`用来创建类并返回这个类的实例

`__init__`将传入的参数来初始化该实例, 以及初始化实例属性, 与`__new__`共同构成了“构造函数”

`__del__`将实例化后的对象销毁, 即为析构函数

类调用:`__call__`

`__call__`允许一个类像函数一样被调用

属性访问:

`__getattr__`: 访问对象不存在的属性时, 调用该方法, 用于定义访问行为

`__setattr_`: 设置对象属性时调用

`__delattr__`: 删除对象属性时调用

上下文管理器

`__enter__`

`__exit__`

迭代器方法:

`__iter__`: 返回一个容器迭代器, 很多情况下会返回迭代器, 尤其是当内置的 `iter()` 方法被调用的时候, 以及当使用 `for x in container` 方式循环的时候. 迭代器是他们本身的对象, 他们必须定义返回 self 的 `__iter__` 方法.

`__next__`: 返回迭代器的下一个元素

> 80.如何知道一个 Python 对象的类型？

```python
demo_obj = range(1, 11)		# 创建一个未知类型的对象
print(type(demo_obj))		# 使用type 判断对象类型
```

> 81.Python 的传参是传值还是传址？

结论: Python 对可变对象 (字典或列表) 传址, 对不可变对象 (数字、字符或元组) 传值.

```python
def demo_func(parm):
    """输出整数或者列表改变后的值
    :param parm: 整数或者列表
    :return:
    """
    if isinstance(parm, int):
        parm += 1
    elif isinstance(parm, list):
        parm.append(1)
    print(parm)
    

if __name__ == '__main__':
    # 定义整数类型
    int_parm = 1
    # 函数内整数值修改 (不可变类型不能修改值, 其实这里是变量另外赋值)
    demo_func(int_parm)		# 输出为2
    # 输出整数值, 查看对象的值是否被修改
    print(int_parm)			# 输出为1, 值未改变, 说明传值
    # 定义列表类型
    list_parm = [1, 2, 3]
    # 函数修改列表
    demo_func(list_parm)	# 输出[1,2,3,1]
    # 查看函数外部列表是否发生改变
    print(list_param)		# 输出[1,2,3,1], 列表发生改变, 说明传址
```

> 82.Python 中的元类(metaclass)使用举例
> 
> 83.简述 any()和 all()方法

`any() ` 判断一个 tuple 或者 list 是否全为空, 全空 False, 不全为空返回 True, 空列表和空元组为 False

`all()` 判断一个 tuple 或者 list 是否全为非空, 有一空则 False, 全不空 True, 空列表和空元组为 True

> 84.filter 方法求出列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

```python
list(filter(lambda x: x % 2 == 1, (i for i in a)))
```

> 85.什么是猴子补丁？
> 86.在 Python 中是如何管理内存的？
> 87.当退出 Python 时是否释放所有内存分配？

### 正则表达式

> 88.使用正则表达式匹配出<html><h1>[百度一下，你就知道](https://link.zhihu.com/?target=http%3A//www.baidu.com)</html>中的地址 a="张明 98 分"，用 `re.sub`，将 98 替换为 100



> 89.正则表达式匹配中`(.*)`和`(.*?)`匹配区别？



> 90.写一段匹配邮箱的正则表达式



### 其他内容

> 91.解释一下 python 中 pass 语句的作用？

Python 的 pass 是空语句, 是为了保持程序结构的完整性;

pass 不做任何事情, 一般用作占位语句;

一般在搭建程序框架的时候或在判断语句中使用

> 92.简述你对 `input()`函数的理解

Python 3.x 中输入 `input()` 函数接受一个标准输入数据, 返回为字符串类型

> 93.python 中的 `is` 和 `==`

is 是身份运算符, 判断两个对象的内存 id 是否相等

== 是比较运算符, 判断两个对象的值是否相等

进行值比较的时候使用 ==, 判断是否是同一对象的时候使用 is

> 94.Python 中的作用域

L (Local) 局部作用域

E (Enclosing) 闭包函数外的函数中

G (Global) 全局作用域

B (Built-in) 内建作用域

以 LEGB 的规则查找, 即: 在局部找不到, 便会去局部外的局部找(例如闭包), 再找不到就会去全局找, 再者去内建中找.

> 95.三元运算写法和应用场景？

三元运算符就是在赋值变量的时候, 可以直接加判断, 然后赋值格式

条件为真时的结果 if 判断的条件 else 条件为假时的结果

```python
# 先定义变量
a = 1
b = 2
# 第一种写法
erroStr = "More" if a > b else "Less"
print(erroStr)  # 运行结果为: Less
# 第二种写法:
print({True: "More", False: "Less"}[a > b])
# 第三种写法:
print(("FalseValue", "TrueValue")[a > b])
```

第一种比较常见, 第二三种比较少见

> 96.了解 `enumerate` 么？

`enumerate()` 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列, 同时列出数据和数据下标, 一般用在 for 循环当中.

以下是 `enumerate()` 方法的语法:

```python
enumerate(sequence, [start=0])
# sequence -- 一个序列、迭代器或其他支持迭代对象
# start -- 下标起始位置

# 例
seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

> 97.列举 5 个 Python 中的标准模块
> 98.如何在函数中设置一个全局变量
> 99.pathlib 的用法举例
> 100.Python 中的异常处理，写一个简单的应用场景
> 101.Python 中递归的最大次数，那如何突破呢？

答案可见https://link.zhihu.com/?target=https%3A//code.activestate.com/recipes/474088/, 不需要会了这个

> 102.什么是面向对象的 mro

MRO：Method Resolution Order(方法解析顺序)

MRO 就是类的方法解析顺序表，其实也就是继承父类方法时的顺序表

MRO 是在 Python 多继承和钻石继承问题上的核心内容，它规定了如何，什么时候，怎样去调用父类的方法

```python
# 输出类的解析继承关系顺序：类名.__mro__
DemoClass.__mro__

# 案例
class A:
    def f(self):
        print("A.f")
        
class B:
    def f(self):
        print("B.f")
。。。不想写了。。没有用这题
```

> 103.`isinstance` 作用以及应用场景？

`isinstance`：判断对象是否是一个已知类型

`isinstance(object, classinfo)`

`object`: 实例对象

`classinfo`: 可以是直接或间接类名、基本类型或者由他们组成的元组

使用场景举例: 判断对象的数据类型, 如参数和返回值判断, 根据不同的数据类型判断类的继承关系, `isinstance` 可以用作判断是否继承了某个父类

科普: `type` 和 `isinstance`

`type` 只输出当前类名, 不管继承关系

`isinstance` 在使用当前类的父类做判断时, 输出为 `True` (多重继承适用)

```python
class A:
    pass

class B(A):
    pass

isinstance(A(), A)		# return True
type(A()) == A			# return True
isinstance(B(), A)		# return True
type(B(), A)			# return False
```

> 104.什么是断言？应用场景？

官方解释： Assert statements are a convenient way to insert debugging assertions into a program. 断言语句是将调试断言插入程序的便捷方式

assert condition: 在 condition 为 True 时不触发， False 触发 AssertionError 错误

```python
>>> assert 1==1
>>> assert 1==0
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    assert 1==0
AssertionError
```

如果没有特别的目的，断言应该用于如下情况：

* 防御性编程
* 运行时对程序逻辑的检测
* 合约性检查（比如前置条件，后置条件）
* 程序中的常量
* 检查文档

> 105.lambda 表达式格式以及应用场景？

lambda 表达式通常是在需要一个函数但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数

格式： lambda 参数1， 参数2…: 参数表达式

适用场景：

简单功能的函数实现

不需要关注函数命名

复用性不高或只用一次的函数

举例：

```python
# 1. 输出1到100内的奇数
print(list(filter(lambda x: x % 2 == 1, range(1, 101))))

# 2. 列表的排序： 按照绝对值大小排序
list_demo = [3, 5, -4, -1, 0, -2, -6]
print(sorted(list_demo, key=lambda x: abs(x)))

# 3. 闭包 lambda
def get_y(a, b):
    return lambda x: a*x + b
y1 = get_y(3, 1)
print(y1(1))
```

> 106.新式类和旧式类的区别

在 Python 3.x 中取消了经典类, 默认都是新式类, 并且不必显式继承 object, 也就是说:

`class Person(object): pass`

`class Person(): pass`

`class Person: pass`

三种写法并无区别, 推荐第一种

Python 2.x 中, 默认都是经典类, 只有显式继承了 object 才是新式类, 即:

`class Person(object): pass` 新式类写法

`class Person(): pass` 经典类写法

`class Person: pass` 经典类写法

新式类和经典类最大的区别: 继承搜索顺序的变化

新式类多继承搜索顺序(广度优先): 先在水平方向查找, 然后再向上查找

经典类多继承搜索顺序(深度优先): 先深入继承树左侧查找, 然后再返回, 开始查找右侧

> 107.`dir()`是干什么用的？

`dir()` 函数不带参数时, 返回当前范围内的变量、方法和定义的类型列表

带参数时, 返回参数的属性、方法列表

如果参数包含方法`__dir__()`, 该方法将被调用. 如果参数不包含`__dir__()`, 该方法将最大限度地收集参数信息

```python
class A:
    def f(self):
        print("A.f")
        
if __name__ == '__main__':
    print(dir())
    # ['A', '__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__']
    print(dir(A))
    # ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'f']
```

> 108.一个包里有三个模块，[demo1.py](https://link.zhihu.com/?target=http%3A//demo1.py), [demo2.py](https://link.zhihu.com/?target=http%3A//demo2.py), [demo3.py](https://link.zhihu.com/?target=http%3A//demo3.py)，但使用 `from tools import *`导入模块时，如何保证只有 demo1、demo3 被导入了。

Python 包中使用`__init__.py`确认导入的包

在 tools 的 `__init__.py` 中添加:

```python
from .demo1 import Demo1
from .demo3 import Demo3
```

> 109.列举 5 个 Python 中的异常类型以及其含义

```python
BaseException	# 所有异常的基类
  +-- SystemExit	# 解释器请求退出
  +-- KeyboardInterrupt		# 用户中断执行(通常是输入^C)
  +-- GeneratorExit		# 生成器(generator)发生异常来通知退出
  +-- Exception		# 常规异常的基类
	+-- StopIteration		# 迭代器没有更多的值
    +-- StopAsyncIteration	# 必须通过异步迭代器对象的__anext__()方法引发以停止迭代
    +-- ArithmeticError		# 各种算术错误引发的内置异常的基类
    |	+-- FloatingPointError	# 浮点计算错误
    |	+-- OverflowError		# 数值运算结果太大无法表示
    |	+-- ZeroDivisionError	# 除(或取模)零(所有数据类型)
    +-- AssertionError		# 当assert语句失败时引发
    +-- AttributeError		# 属性引用或赋值失败
    +-- BufferError			# 无法执行与缓冲区相关的操作时引发
    +-- EOFError			# 当input()函数在没有读取任何数据的情况下达到文件结束条件(EOF)时引发
    +-- ImportError			# 导入模块/对象失败
    |	+-- ModuleNotFoundError	# 无法找到模块或在sys.modules中找到None
    +-- LookupError			# 映射或序列上使用的键或索引无效时引发的异常的基类
    |	+-- IndexError		# 序列中没有此索引(index)
    |	+-- KeyError		# 映射中没有这个键
    +-- MemoryError			# 内存溢出错误(对于Python 解释器不是致命的)
    +-- NameError			# 未声明/初始化对象(没有属性)
    |	+-- UnboundLocalError	# 访问未初始化的本地变量
    +-- OSError	# 操作系统错误,EnvironmentError,IOError,WindowsError,socket.error和					# mmap.error已合并到OSError中,构造函数可能返回子类
    |	+-- BlockingIOError	# 操作将阻塞对象(e.g. socket) 设置为非阻塞操作
    |	+-- ChildProcessError	# 在子进程上的操作失败
    |	+-- ConnectionError	# 与连接相关的异常的基类
  	|....
```

太多了…不想写了..挑几个常见的吧:

`KeyboardInterrupt`: 用户中断执行(通常是输入^C)

`StopIteration`: 迭代器没有更多的值

`AssertionError`:当 assert 语句失败时引发

`AttributeError`:属性引用或赋值失败

`RuntimeError`:在检测到不属于任何其他类别的错误时触发

`SyntaxError`: Python 语法错误

`TypeError`:操作或函数应用于不适当类型的对象

`ValueError`: 操作或函数接收到具有正确类型但值不合适的参数

> 110.`copy` 和 `deepcopy` 的区别是什么？

* `copy` 仅拷贝对象本身, 而不拷贝对象中引用的其他对象
* `deepcopy` 除拷贝对象本身, 而且拷贝对象中引用的其他对象.(子对象)

`copy` 不会为子对象额外创建新的内存空间, 当子对象被修改之后, 这个子对象的引用都会发生改变

`deepcopy` 是一个新对象的创建, 只是用了和被拷贝对象相同的值, 子对象改变不会影响被拷贝对象

> 111.代码中经常遇到的`*args`, `**kwargs` 含义及用法。

args 是 arguments 的缩写, 表示位置参数

kwargs 是 keyword arguments 的缩写, 表示关键字参数

```python
def demo_func(*args, **kwargs):
    # args 是一个元组类型
    print(args[1])
    # kwargs 是一个字典类型
    print(kwargs.keys())
    
    
if __name__ == '__main__':
    # 直接传参, 但关键字类型必须为str
    demo_func(1, 2, 3, a=1, b=2)
    # 使用*和**进行解包
    demo_func(*(1, 2, 3), **{"a": 1, "b": 2})
```

> 112.Python 中会有函数或成员变量包含单下划线前缀和结尾，和双下划线前缀结尾，区别是什么?

**<u>单下划线开头</u>**的命名方式常用于模块中, 在一个模块中以单下划线开头的变量和方法会被默认划入模块内部范围. 当使用 `from my_module import *` 导入时, 单下划线开头的变量和方法是不会被导入的. 但是使用 `import my_module` 导入的话, 仍然可以用 `my_module._var` 这样的形式访问属性或方法.

**<u>单下划线结尾</u>**的命名方式也存在, 但是不常用, 其实也不推荐用. 这种命名方式的作用就是为了和 Python 的一些内置关键词区分开来, 假设我们想给一个变量命名为 class, 但是这会跟 Python 的关键词 class 冲突, 所以我们只好退一步使用单下划线结尾命名, 也就是 class_.

**<u>双下划线开头和结尾</u>**的是一些 Python 的“魔术”对象, 如类成员的 `__init__`, `__del__`, `__add__`, `__getitem__`等, 以及全局的`__file__`, `__name__`等. Python 官方推荐永远不要将这样的命名方式应用于自己的变量或函数, 而是按照文档说明来使用.

**<u>双下划线开头</u>**的命名方式有实际的作用, 采用这种命名的变量或方法无法直接通过“对象名.变量名(方法名)”这样的方式访问.

> 113.w、a+、wb 文件写入模式的区别

`r`：读取文件，若文件不存在则会报错

`w`：写入文件，若文件不存在则会先创建再写入，会覆盖原文件

`a`：写入文件，若文件不存在则会先创建再写入，但不会覆盖原文件，而是追加在文件末尾

`rb`, `wb` 分别与`r`, `w`类似，用于读写二进制文件

`r+`：可读，可写，文件不存在也会报错，写操作时会覆盖

`w+`：可读，可写，文件不存在先创建，会覆盖

`a+`：可读，可写，文件不存在先创建，不会覆盖，追加在末尾

> 114.举例 `sort` 和 `sorted` 的区别

```python
demo_list = [1, 3, 4, 2, 7, 5]
# sorted 是一个函数, 返回一个新的 list
result_list = sorted(demo_list)
print(result_list)
# sort 是实例方法, 直接作用在 list 本身, 没有返回新的 list
demo_list.sort()
print(demo_list)
```

> 115.什么是负索引？

负索引是指使用负数作为索引, -1代表数组的最后一位

> 116.`pprint` 模块是干什么的？

```python
# pprint 用于输出一个整齐美观 Python 数据的结构
import pprint

demo_list = [str(i)*20 for i in range(10)]
# indent 是指句首缩进
pp_object = pprint.PrettyPrinter(indent=4)
pp_object.pprint(demo_list)		# 整齐输出
print(demo_list)				# 只输出一行
```

> 117.解释一下 Python 中的赋值运算符

| 运算符 | 描述             | 实例                                 |
| :----- | ---------------- | ------------------------------------ |
| =      | 简单的赋值运算符 | c = a + b 将 a + b 的运算结果赋值为c |
| +=     | 加法赋值运算符   | c += a 等效于 c = c + a              |
| -=     | 减法赋值运算符   | c -= a 等效于 c = c - a              |
| *=     | 乘法赋值运算符   |                                      |
| /=     | 除法赋值运算符   |                                      |
| %=     | 取模赋值运算符   |                                      |
| **=    | 幂赋值运算符     |                                      |
| //=    | 取整除赋值运算符 |                                      |

> 118.解释一下 Python 中的逻辑运算符

| 运算符 | 逻辑表达式 | 描述     | 实例 |
| ------ | ---------- | -------- | ---- |
| and    | x and y    | 布尔“与” |      |
| or     | x or y     | 布尔“或” |      |
| not    | not x      | 布尔“非” |      |

> 119.讲讲 Python 中的位运算符

| 运算符 | 描述                                                         | 实例 |
| ------ | ------------------------------------------------------------ | ---- |
| &      | 按位与运算符: 参与运算的两个值, 如果两个相应位都为1, 则该位的结果为1, 否则为0 |      |
| \|     |                                                              |      |
| ^      |                                                              |      |
| ~      |                                                              |      |
| <<     |                                                              |      |
| >>     |                                                              |      |

> 120.在 Python 中如何使用多进制数字？



> 121.怎样声明多个变量并赋值？



### 算法和数据结构

> 122.已知：
>
> ```python
> AList = [1, 2, 3]
> BSet = {1, 2, 3}
> ```
>
> (1) 从 AList 和 BSet 中 查找 4，最坏时间复杂度那个大？
> (2) 从 AList 和 BSet 中 插入 4，最坏时间复杂度那个大？



> 123.用 Python 实现一个二分查找的函数
> 124.python 单例模式的实现方法

```python
class SingleCase:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls, *args, **kwargs)
        return cls._instance
    
    
if __name__  == '__main__':
    a = SingleCase()
    b = SingleCase()
```

参考: [Python单例模式(Singleton)的N种实现](https://zhuanlan.zhihu.com/p/37534850)

很多初学者喜欢用全局变量, 因为这比函数的参数传来传去更容易让人理解. 确实在很多场景下用全局变量很方便. 不过如果代码规模增大, 并且有多个文件的的时候, 全局变量就会变得比较混乱. 你可能不知道在哪个文件中定义了相同类型甚至重名的全局变量, 也不知道这个变量在程序的某个地方被做了怎样的操作.

因此对于这种情况, 有种更好的实现方式: 单例(Singleton)

单例模式保证了在程序的不同位置都可以且仅可以取到同一个对象实例: 如果实例不存在, 会创建一个实例; 如果已存在就会返回这个实例. 因为单例是一个类, 所以你也可以为其提供相应的操作方法, 以便于对这个实例进行管理.

举例来说: 比如开发一款游戏软件, 游戏中需要有“场景管理器”这种东西, 用来管理游戏场景切换、资源载入、网络连接等任务. 这个管理器需要有多种方法和属性, 在代码中很多地方会被调用, 且被调用的必须是同一个管理器, 否则既容易产生冲突, 也会浪费资源. 这种情况下, 单例模式就是一个很好的实现方法.

使用函数装饰器实现单例:

...



> 125.使用 Python 实现一个斐波那契数列



> 126.找出列表中的重复数字



> 127.找出列表中的单个数字



> 128.写一个冒泡排序



> 129.写一个快速排序



> 130.写一个拓扑排序
> 131.python 实现一个二进制计算
> 132.有一组“+”和“-”符号，要求将“+”排到左边，“-”排到右边，写出具体的实现方法。
> 133.单链表反转
> 134.交叉链表求交点
> 135.用队列实现栈
> 136.找出数据流的中位数
> 137.二叉搜索树中第 K 小的元素

### 爬虫相关

> 138.在 requests 模块中，requests.content 和 requests.text 什么区别



> 139.简要写一下 lxml 模块的使用方法框架
> 140.说一说 scrapy 的工作流程
> 141.scrapy 的去重原理
> 142.scrapy 中间件有几种类，你用过哪些中间件
> 143.你写爬虫的时候都遇到过什么？反爬虫措施，你是怎么解决的？
> 144.为什么会用到代理？
> 145.代理失效了怎么处理？



> 146.列出你知道 header 的内容以及信息



> 147.说一说打开浏览器访问 [百度一下，你就知道](https://link.zhihu.com/?target=http%3A//www.baidu.com) 获取到结果，整个流程。



> 148.爬取速度过快出现了验证码怎么处理

> 149.scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？
> 150.分布式爬虫主要解决什么问题
> 151.写爬虫是用多进程好？还是多线程好？ 为什么？



> 152.解析网页的解析器使用最多的是哪几个

lxml, re, beautifulsope

> 153.需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？
> 154.验证码的解决（简单的：对图像做处理后可以得到的，困难的：验证码是点击，拖动等动态进行的？）
> 155.使用最多的数据库（mysql，mongodb，redis 等），对他的理解？

### 网络编程

> 156.TCP 和 UDP 的区别？



> 157.简要介绍三次握手和四次挥手



> 158.什么是粘包？ socket 中造成粘包的原因是什么？ 哪些情况会发生粘包现象？

### 并发

> 159.举例说明 conccurent.future 的中线程池的用法
> 160.说一说多线程，多进程和协程的区别。
> 
> 161.简述 GIL



> 162.进程之间如何通信



> 167.解释什么是异步非阻塞？



> 168.threading.local 的作用？



### Git 面试题

> 169.说说你知道的 git 命令



> 170.git 如何查看某次提交修改的内容

# [110道Python面试题（真题）](https://zhuanlan.zhihu.com/p/54430650)

## 001~010

> 1. 一行代码实现1--100之和

解答: 利用 `sum()` 函数求和

```python
>>> sum(range(1,101))
```

这道题的考点:

1. `sum` 可以接受一个可迭代对象
2. `range(1, 101)`除了返回一个序列外, 它也是一个可迭代对象

> 2. 如何在一个函数内部修改全局变量

解答: 利用 global 在函数中声明 修改全局变量

> 3. 列出5个 Python 标准库

解答: 

`os`: 提供了不少与操作系统相关联的函数

`sys`: 通常用于命令行参数

`re`: 正则匹配

`math`: 数学运算

`datetime`: 处理时期时间

> 4. 字典如何删除键和合并两个字典

解答:

> 9. 一句话解释什么样的语言能够用装饰器?

函数可以作为参数传递的语言，可以使用装饰器

## 011~020

> 11. 简述面向对象中`__new__`和`__init__`区别

`__init__`是初始化方法，创建对象后，就立刻被默认调用了，可接收参数。

`__new__` 至少要有一个参数 `cls`， 返回实例化出来的实例，这点在自己实现`__new__`时要特别注意，可以return 父类 (通过 `super(当前类名, cls)`)`__new__` 出来的实例，或者直接是object 的 `__new__`出来的实例

`__init__` 有一个参数 self, 就是这个 `__new__`返回的实例， `__init__`在 `__new__` 的基础上可以完成一些其他初始化的动作， `__init__` 不需要返回值

如果`__new__`创建的是当前类的实例，会自动调用`__init__`函数，通过 return 语句里面调用的 `__new__`函数的第一个参数是 cls 来保证是当前类实例，如果是其他类的类名，那么实际创建返回的就是其他类的实例，其实就不会调用当前类的`__init__`函数，也不会调用其他类的`__init__`函数

```python
class A:
    def __init__(self):
        print("这是 init 方法", self)
        
    def __new__(cls):
        print("这是cls的ID", id(cls))
        print("这是 new 方法", object.__new__(cls))
        return object.__new__(cls)
    
A()
print("这是类A的ID", id(A))
```

> 13. 列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]

```python
>>> s = [1,2,3,4,5]
>>> res = list(map(lambda x: x ** 2, s))
>>> res
[1, 4, 9, 16, 25]
>>> res1 = [x for x in res if x > 10]
>>> res1
[16, 25]
>>>
```

> 14. Python 中生成随机整数、随机小数、0-1之间小数方法

```python
import random
import numpy as np
result = random.randint(10, 20)
res =np.random.randn(5)
rest = random.random()
```

随机整数： `random.randint(a, b)` 生成区间内的整数

随机小数： 习惯用 `numpy` 库， 利用 `np.random.randn(5)`

0-1 随机小数： `random.random()`, 括号中不传参

> 15. 避免转义给字符串加哪个字母表示原始字符串？

r, 表示需要原始字符串， 不转义特殊字符

> 16.  `<div class="name">中国</div>`， 用正则匹配出标签里的内容（“中国”），其中class 的类名是不确定的



> 17. Python 中断言方法举例（与114重复）

assert 方法断言成功，则程序继续执行，断言失败，则程序报错

```python
a = 3
assert(a>1)
print("断言成功， 程序继续往下执行")

b = 4
assert(b>7)
print("断言失败，程序报错")
```

> 18. 数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句

```sql
select distinct name from student
```

> 19. 10个 Linux 常用命令

ls tail less head mkdir touch cd pwd rm cp mv cat more grep echo

> 20. Python2 和 Python3 的区别有哪些?

## 021~030

> 21. 列出 Python 中可变数据类型和不可变类型, 并简述原理



> 22. s = "ajldjlajfdljfddd"，去重并从小到大排序输出"adfjl”

解答:

`set` 去重, 去重转成 `list`, 利用 sort 方法排序, `reverse=False` 是从小到达排

`list` 是可变数据类型, `s.sort` 时候没有返回值, 所以注释的代码写法不正确

```python
>>> s = "ajldjlajfdljfddd"
>>> s = set(s)
>>> s = list(s)
>>> s.sort(reverse=False)
# s = s.sort(reverse=False)
>>> res = "".join(s)
>>> print(res)
adfjl
```

> 23. 用 lambda 函数实现两个数相乘

```python
>>> a = lambda x, y: x * y
>>> print(a(4, 5))
20
```

> 24. 字典根据键从小到大排序, `dic = {"name":"zs","age":18,"city":"深圳","tel":"1362626627"}`

```python
>>> dic={"name":"zs","age":18,"city":"深圳","tel":"1362626627"}
>>> lis = sorted(dic.items(), key=lambda i: i[0], reverse=False)
>>> lis
[('age', 18), ('city', '深圳'), ('name', 'zs'), ('tel', '1362626627')]
>>> dict(lis)
{'age': 18, 'city': '深圳', 'name': 'zs', 'tel': '1362626627'}
```

> 25. 利用collections库的Counter方法统计字符串每个单词出现的次数"kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"

```python
>>> from collections import Counter
>>> a = "kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"
>>> res = Counter(a)
>>> print(res)
Counter({'l': 9, ';': 6, 'h': 6, 'f': 5, 'a': 4, 'j': 3, 'd': 3, 's': 2, 'k': 1, 'g': 1, 'b': 1})
```

## 031~040

> 34. 数据库优化查询方法

外键、索引、联合查询、选择特定字段等等



## 041~050

> 43. 举例说明zip（）函数用法

```python
>>> a = (1, 2, 3)
>>> b = (4, 5, 6)
>>> c = (7, 8, 9)
>>> list(zip(a, b, c))
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
>>> dict(zip(a,b))
{1: 4, 2: 5, 3: 6}
```

---

原答案：

`zip()`函数在运算时，会以一个或多个序列（可迭代对象）作为参数，返回一个元组的列表。同时将这些序列中并排的元素配对。

`zip()`参数可以接受任何类型的序列，同时也可以有两个以上的参数，当传入参数的长度不同时，`zip()`能自动以最短序列长度为准进行截取，获得元组。

```python
>>> a = [1, 2]				# 列表
>>> b = [3, 4]
>>> res = [i for i in zip(a,b)]
>>> print(res)
[(1, 3), (2, 4)]
>>> a = (1, 2)				# 元组
>>> b = (3, 4)
>>> res = [i for i in zip(a,b)]
>>> print(res)
[(1, 3), (2, 4)]
>>> a = "ab"				# 字符串
>>> b = "xyz"
>>> res = [i for i in zip(a,b)]
>>> print(res)
[('a', 'x'), ('b', 'y')]
```



> 45. 写5条常用sql语句

```sql
insert into table_name(row_names) values("xxx");
update table_name set col_name = "xxx" where xxx=xxx
delete from table_name where xxx=xxx
select * from table_name where xxx=xxx
create table if not exists(
)
```

---

原答案：

```sql
show databases;
show tables;
desc 表名;
select * from 表名;
delete from 表名 where id=5;
update 表名 set gender=0,hometown="北京" where id=5;
```

> 48. 提高python运行效率的方法

1. 使用生成器, 因为可以节约大量内存
2. 循环代码优化, 避免过多重复代码的执行
3. 核心模块用 CPython PyPy 等, 提高效率
4. 多进程、多线程、协程
5. 多个 if elif 条件判断, 可以把最有可能先发生的条件放到前面写, 这样可以减少程序判断的次数, 提高效率


> 49. 简述 MySQL 和 Redis 区别

MySQL：关系型数据库，数据保存在磁盘中，检索的话，会有一定的IO操作，访问速度相对慢

Redis：内存型非关系数据库，数据保存在内存中，速度快

## 051~060

> 57. 分别从前端、后端、数据库阐述web项目的性能优化

前端优化:

1. 减少 http 请求, 例如制作精灵图
2. html 和 css 放在页面上部, JavaScript 放在页面下面, 因为 js 加载比 html 和 css 加载慢, 所以要优先加载 html 和 css, 以防页面显示不全, 性能差, 也影响用户体验

后端优化:

1. 缓存存储读写次数高, 变化少的数据, 比如网站首页的信息、商品的信息等. 应用程序读取数据时, 一般是先从缓存中读取, 如果读取不到或数据已失效, 再访问磁盘数据库, 并将数据再次写入缓存
2. 异步方式, 如果有耗时操作,可以采用异步, 比如 celery
3. 代码优化, 避免循环和判断次数太多, 如果多个if else 判断, 优先判断最有可能先发生的情况

数据库优化:

1. 如有条件, 数据可以存放于 redis, 读取速度快
2. 建立索引、外键等

> 59. 列出常见 MYSQL 数据存储引擎

InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择 InnoDB 有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择 InnoDB， 因为支持事务的提交（commit）和回滚（rollback）

MyISAM：插入数据块，空间和内存使用比较低。如果表主要是用于插入新纪录和读出记录，那么选择 MyISAM 能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用

MEMORY：所有数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择 MEMORY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。

> 60. 计算代码运行结果，`zip`函数历史文章已经说了，得出`[("a",1),("b",2)，("c",3),("d",4),("e",5)]`

```python
A = zip(("a", "b", "c", "d", "e"), (1, 2, 3, 4, 5))
A0 = dict(A)
A1 = range(10)
A2 = list(zip(("a", "b", "c", "d", "e"), (1, 2, 3, 4, 5)))
A3 = [i for i in A1 if i in A0]
A4 = [A0[s] for s in A0]
```

求 A0, A2, A3 和 A4 的结果

```python
print("A0: ", A0)	# {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
print(A2)			# [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]
print(A3)			# []
print(A4)			# [1, 2, 3, 4, 5]
```

扩展: `dict()` 创建字典的新方法

```python
s = dict([["name", "zs"], ["age", 18]])		# 里面是小列表
s = dict([("name", "zs"), ("age", 18)])		# 里面是小元组
# 打印结果都为: {'name': 'zs', 'age': 18}
```

## 061~070

> 61. 简述同源策略

同源策略需要同时满足以下三点要求:

1. 协议相同
2. 域名相同
3. 端口相同

http:test.com 与 https:test.com 不同源 — 协议不同

http:test.com 与 http:admin.com 不同源 — 域名不同

http:test.com 与 http:test.com:8081 不同源 — 端口不同

只要不满足其中任意一个要求, 就不符合同源策略, 就会出现“跨域”

> 62. 简述 cookie 和 session 的区别

1. session 在服务器端, cookie 在客户端(浏览器)
2. session 的运行依赖 session id, 而 session id 是存在 cookie 中的, 也就是说, 如果浏览器禁用了 cookie, 同时 session 也会失效, 存储 session 时, 键与 cookie 中的 session id 相同, 值是开发人员设置的键值对信息, 进行了 base64 编码, 过期时间由开发人员设置
3. cookie 安全性比 session 差

> 63. 简述多线程、多进程

进程:

1. 操作系统进行资源分配和调度的基本单位, 多个进程之间相互独立
2. 稳定性好, 如果一个进程崩溃, 不影响其他进程, 但是进程消耗资源大, 开启的进程数量有限制

线程:

1. CPU 进行资源分配和调度的基本单位, 线程是进程的一部分, 是比进程更小的能独立运行的基本单位, 一个进程下的多个线程可以共享该进程的所有资源
2. 如果 IO 操作密集, 则可以多线程运行效率高, 缺点是如果一个线程崩溃, 都会造成进程的崩溃

应用:

IO 密集的用多线程, 在用户输入, sleep 的时候可以切换到其他线程执行, 减少等待时间

CPU 密集的用多进程, 因为假如 IO 操作少, 用多线程的话, 因为线程共享一个全局解释器锁, 当前运行的线程会霸占 GIL,其他线程没有 GIL, 就不能充分利用多核的优势

> 64. 简述 `any()` 和 `all()` 方法



> 65. IOError、AttributeError、ImportError、IndentationError、IndexError、KeyError、SyntaxError、NameError分别代表什么异常

`IOError`: 输入输出异常

`AttributeError`: 试图访问一个对象没有的属性

`ImportError`: 无法引入模块或包, 基本是路径问题

`IndentationError`: 语法错误, 代码没有正确的对齐

`IndexError`: 下标索引超出序列边界

`KeyError`: 试图访问你字典里不存在的键

`SyntaxError`: Python 代码逻辑语法出错, 不能执行

`NameError`: 使用一个还未赋予对象的变量

> 68. C:\Users\ry-wu.junya\Desktop>python 1.py 22 33命令行启动程序并传参，print(sys.argv)会输出什么数据？

文件名和参数构成的列表

```shell
['1,py', '22', '33']
```



## 071~080



> 74. 列表嵌套字典的排序，分别根据年龄和姓名排序
>
>     `foo = [{"name":"zs","age":19},{"name":"ll","age":54},{"name":"wa","age":17},`
>
>     `{"name":"df","age":23}]`

```python
foo = [{"name":"zs","age":19},{"name":"ll","age":54}, {"name":"wa","age":17},				   {"name":"df","age":23}]
a = sorted(foo, key=lambda x: x['age'], reverse=True)   # 年龄从大到小
print(a)
b = sorted(foo, key=lambda x: x['name'])		# 姓名从小到大
print(b)
```

> 75. 列表嵌套元组，分别按字母和数字排序
>
>     `foo = [("zs", 19), ("ll", 54), ("wa", 23), ("df", 23), ("xf", 23)]`

```python
foo = [("zs", 19), ("ll", 54), ("wa", 23), ("df", 23), ("xf", 23)]
a = sorted(foo, key=lambda x:x[1], reverse=True)
print(a)
b = sorted(foo, key=lambda x:x[0])
print(b)
```





> 76. 列表嵌套列表排序，年龄数字相同怎么办？
>
>     `foo = [["zs", 19], ["ll", 54], ["wa", 23], ["df", 23], ["xf", 23]]`

```python
foo = [["zs", 19], ["ll", 54], ["wa", 23], ["df", 23], ["xf", 23]]
a = sorted(foo, key=lambda x:(x[1], x[0]))    # 年龄相同时添加参数, 按字母排序
```





> 80. 最后出一道检验题目，根据字符串长度排序，看排序是否灵活运用
>
>     `s = ["ab", "abc", "a", "djkj"]`

```python
s = ["ab", "abc", "a", "djkj"]
b = sorted(s, key=lambda x:len(x))
print(b, s)
s.sort(key=len)
print(s)
```

## 081~090

> 81. 举例说明SQL注入和解决办法

当以字符串格式化书写方式的时候，如果用户输入的有;+SQL 语句，后面的 SQL 语句会执行，比如例子中的 SQL 注入会删除数据库 demo

```python
# SQL 注入
# 例如一条 SQL 语句是：
input_name = "zs"
sql = 'select * from demo where name="%s"' % input_name
print("正常 SQL 语句", sql)

input_name = "zs;drop database demo"
sql = 'select * from demo where name="%s"' % input_name
print("SQL 注入语句", sql)
```

解决方式：通过传参数方式解决 SQL 注入

```python
params = [input_name]
count = cs1.execute('select * from goods where name=%s', params)
```



> 86. MyISAM 与 InnoDB 区别

1. InnoDB 支持事务， MyISAM 不支持，这一点非常重要。 事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM 就不可以了。
2. MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到安全性较高的应用
3. InnoDB 支持外键，MyISAM 不支持
4. 对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中可以和其他字段一起建立联合索引
5. 清空整个表时，InnoDB 是一行一行的删除，效率非常慢，MyISAM 则会重建表

> 90. 用两种方法去空格

```python
str = "hello world ha ha"
res = str.replace(" ", "")
print(res)

list = str.split(" ")
res = "".join(list)
print(res)
```

## 091~100

> 92. `int("1.4")`, `int(1.4)` 输出结果？

`int("1.4")` 报错， `int(1.4)` 输出 1

> 93. 列举 3 条以上 PEP8 编码规范

1. 顶级定义之间空两行， 比如函数或者类定义
2. 方法定义、类定义与第一个方法之间，都应该空一行
3. 三引号进行注释
4. 使用 Pycharm、Eclipse 一般使用 4 个空格来缩进代码



> 97. `r`, `r+`, `rb`, `rb+`文件打开模式区别

| 访问模式 | 说明                                                         |
| :------: | :----------------------------------------------------------- |
|   `r`    | 以只读方式打开文件，文件的指针将会放在文件的开头。这是默认模式 |
|   `w`    |                                                              |
|   `a`    |                                                              |
|   `rb`   | 以二进制格式打开一个文件用于只读，文件指针将会放在文件的开头，这是默认模式 |
|   `wb`   |                                                              |
|   `ab`   |                                                              |
|   `r+`   | 打开一个文件用于读写，文件指针将会放在文件的开头             |
|   `w+`   |                                                              |
|   `a+`   |                                                              |
|  `rb+`   | 以二进制格式打开一个文件用于读写，文件指针将会放在文件的开头 |
|  `wb+`   |                                                              |
|  `ab+`   |                                                              |

> 98. Linux 命令重定向 > 和 >>

Linux 允许将命令执行结果重定向到一个文件，将本应显示在终端上的内容输出/追加到指定文件中

`>` 表示输出，会覆盖文件原有内容

`>>` 表示追加，会将文件内容追加到已有文件的末尾

用法示例：

将 echo 输出的信息保存到 1.txt 里 ： `echo Hello Python > 1.txt`

将 tree 输出的信息追加到 1.txt 文件的末尾： `tree >> 1.txt`

## 101~110

> 108. Python 中读取 Excel 文件的方法

```python
>>> import pandas as pd
>>> df = pd.read_excel("test_excel.xlsx")
>>> print(df)
    姓名  年龄   城市
0   张三  11   北京
1   李四  12   深圳
2   王五  13   上海
3  NaN  14  NaN
```













