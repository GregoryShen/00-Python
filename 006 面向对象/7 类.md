## Python编程：从入门到实践

类：表示现实世界中的事物和情景

基于这些类来创建对象。

编写类时：定义一大类对象都有的通用行为。

基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。

根据类来创建对象被称为<u>**实例化**</u>，这让我们能够使用类的实例。

1. 创建类
   1. 方法`__init__()`
   2. 在Python 2.7 中创建类（略）

> 为何必须在方法定义中包含形参self呢？
>
> 因为Python调用这个`__init__()`方法来创建Dog实例时，将自动传入实参self。
>
> 事实上每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。
>
> 以self为前缀的变量都可以供勒种的所有方法使用，我们还可以通过类的任何实例来访问这些变量。
>
> self.name = name 获取存储在形参name中的值，并将其存储到变量name中，然后**该变量被关联到当前创建的实例。**
>
> 像这样可以通过实例访问的变量称为**<u>属性</u>**

2. 根据类创建实例

可将类视为有关如何创建实例的说明。Dog类是一系列说明，让Python知道如何创建表示特定小狗的实例。

* 访问属性：通过句点表示法

```python
my_dog.name
```

这种语法演示了Python是如何获取属性的值。在这里，Python先找到实例my_dog, 再查找与这个实例相关联的属性name。在Dog类中引用这个属性时，使用的是`self.name` 。

`title()`函数的作用是将首字母大写。

`str()`将age的值6转换为字符串

* 调用方法

根据Dog类创建实例后，就可以使用句点法来调用Dog类中的任何方法

```python
my_dog = Dog('willie', 6)
my_dog.sit()
my_dog.roll_over()
```

* 创建多个实例

你可以按需求根据一个类创建任意数量的实例，条件是将每个实例都存储在不同的变量中，或占用列表或字典不同的位置。

----

使用类＆实例

可以使用类来模拟现实世界中的很多情景。

类编写好后，你的大部分时间都将花在使用根据类创建的实例上。

你需要执行的一个重要任务是修改实例的属性。

可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。

**修改属性的值**

三种不同方式：

1. 直接通过实例进行修改

2. 通过方法进行设置

   可以在方法中进行设置，在修改属性前检查指定的读数是否合理，如果新指定的里程大于等于原来的

   里程（self.odometer_reading)，就将里程表读数改为新指定的里程；否则就发出警告，指出不能将里程表往回拨

3. 通过方法进行递增（增加特定的值）

   可以轻松的修改这个方法，以禁止增量为负值，从而防止有人利用它来回拨里程表

**注意**：可以使用2、3方法来控制用户修改属性值，但能够访问程序的人都可以通过直接访问属性来将里程表修改为任何值，要确保安全，畜类进行类似前面的基本检查外，还需要特别注意细节。

#### 继承

----

编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可以使用**继承**。

一个类继承另一个类时，它将自动获得另一个类的所有属性和方法：原有的类称为父类，新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。

##### 子类的方法`__init__()`

创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法`__init__()`需要父类施以援手。

##### 重写父类方法

对于父类的方法，只要它不符合子类模拟的实物的行为，都可以对其进行重写。为此，可以在子类中定义这样的方法，即它与要重写的方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。

使用继承时，可让子类保留从父类那里继承而来的精华，并剔除不需要的糟粕。

##### 将实例用作属性

使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。可以将大型类拆分成多个协同工作的小类

##### 模拟实物

现实世界的建模方法并没有对错之分。有些效率更高，但要找出效率最高的表示法，需要经过一定的实践。

#### 导入类

随着你不断地给类添加功能，文件可能变得很长，即使你妥善地使用了继承亦如此。为遵循Python的总体理念，应让文件尽可能整洁。为在这方面提供帮助，Python允许你将类存储在模块中，然后在主程序中导入所需的模块。

##### 导入单个类

导入类是一种有效的编程方式。如果在这个程序中包含了整个Car类，就会很长。通过将这个类移动到一个模块中，并导入该模块，你依然可以使用其所有功能，但主程序文件变得整洁而易读了。

这还能让你将大部分逻辑存储在独立的文件中：确定类像你希望的那样工作后，你就可以不管

这些文件，而专注于主程序的高级逻辑了。

##### 在一个模块中存储多个类

同一个模块中的类应该存在某种相关性，但可根据需要在一个模块中存储任意数量的类。

类Battery和ElectricCar都可以帮助模拟汽车，因此将它们都加入模块`car.py`

##### 从一个模块中导入多个类

可以根据需要在程序文件中导入任意数量的类。

##### 导入整个模块

可以导入整个模块，再使用句点法表示访问需要的类。由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。

```python
import car
```

我们使用语法`module_name.class_name`访问需要的类。

##### 导入模块中所有的类

要导入模块中的每个类，可以使用：

```python
from module_name import *
```

不推荐使用这种导入方式，原因：

1. 如果只要看一下文件开头的import语句，就能清楚地知道程序使用了哪些类，将大有裨益，但这种方式没有明确地指出你使用了模块中的哪些类
2. 

----

## 廖雪峰课程

### 面向对象编程

OOP是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。

面向对象把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中类的概念。

面向对象的设计思想是抽象出class，根据class创建Instance。

面向对象的抽象程度又比函数要高，因为一个class既包含数据，又包含操作数据的方法。

#### 类和实例

类是抽象的模板，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自

的数据可能不同。

<u>**可以给实例变量绑定属性**</u>

由于类可以起到模板的作用，因此，可以在创建实例的时候，把属性绑定上去

`__init__`方法的第一个参数永远是self， 表示创建的实例本身， 因此，在`__init__`方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身

##### 数据封装

面向对象编程的一个重要特点就是数据封装。

我们可以通过函数来访问这些数据，但是，既然实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在类内部定义访问数据的函数，这样，就把“数据”给封装起来了。

这些封装数据的函数是和类本身关联起来的，我们称之为类的方法：

我们从外部看类，就只需要知道，创建实例需要给出两个属性值，而如何打印，是在类内部定义的，这些数据和逻辑被"封装"起来了，调用很容易，但却不用知道内部实现的细节。

封装的另一个好处是可以给类增加新的方法

方法就是与实力绑定的函数，和普通函数不同，方法可以直接访问实例的数据

通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节

和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然他们都是同一个类的不同实例，但拥有的变量名称都可能不同

#### 访问限制

在class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的<u>**方法**</u><u>*[这里我们说的是method]</u>*来操作数据，这样，就隐藏了内部的复杂逻辑。

但是，还是可以直接通过直接修改属性的方式来修改值。

如果要让内部属性不被外部访问，可以把属性名称前加两个下划线。在Python中，实例的变量名如果以

双下划线开头，就变成了一个私有变量，只有内部可以访问，外部不能访问。

（实在想访问的话可以通过 `实例变量._类名__属性名`来访问）

不过强烈不建议这么干，因为不同版本的Python解释器可能会把`__属性名`改成不同的变量名

但是如果外部代码要获取属性值怎么办，可以给类增加get方法

如果要修改属性值怎么办，增加set方法

**这种通过方法来修改的好处：可以对参数做检查，避免传入无效的参数**

需要注意的是，在Python中，变量名类似`__xxx__`是特殊变量，可以直接访问，不是私有变量。

单下划线的，这么骚气的变量命名。这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”

#### 继承和多态

当子类和父类都存在相同的方法时，我们说，子类方法覆盖了父类方法，在代码运行的时候，总是回调用子类的方法，这就是**多态**

当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型一样。

判断一个变量是否是某个类型可以用`isinstance()`判断

```python
isinstance(要判断的东西，想要匹配的类型)
```

在继承关系中，如果一个实例的数据类型是某个子类，那他的数据类型也可以被看做是父类。反之不行。

```python
def run_twice(animal):
    animal.run()
    animal.run()
```



#### 获取对象信息

判断对象类型，用`type()`函数

`type()`函数返回的是对应的class类型，如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：

判断基本数据类型可以直接写`int`,`str`等，如果要判断一个对象是否是函数，可以用types模块中定义的常量：

对于class的继承关系来说，使用`type()`就很不方便。我们要判断class的类型，可以使用`isinstance()`函数。

`isinstance()`判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。

能用type()判断的基本类型也可以用isinstance()判断

并且还以判断一个变量是否是某些类型中的一种：

```python
isinstance([1,2,3], (list, tuple))
```

总是优先使用`isinstance()`判断类型，可以将指定类型及其子类“一网打尽”



#### 实力属性和类属性

因为是动态语言，根据类创建的实例可以任意绑定属性。

给实例绑定属性的方法是通过实例变量，或者通过`self`变量



如果类本身要绑定一个属性，可以直接在class中定义属性，这种属性是类属性，归类所有

当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到



在编写程序时，不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的是类属性

### 面向对象高级编程

数据封装、继承和多态只是OOP中最基础的3个概念。

还有多重继承、定制类、元类等概念

#### 使用`__slots__`

给实例绑定一个方法：

```python
def set_age(self, age):
    self.age = age
    
from types import MethodType
s.set_age = MethodType(set_age, s)
```

但是 给一个实例绑定的方法，对另一个实例是不起作用的。为了给所有实例都绑定方法，可以给class绑定方法：

```python
def set_score(self, score):
    self.score = score
Student.set_score = set_score
```

通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。

##### 使用`__slots__`

如果我们想要限制实例的属性，比如，只允许对Student实例添加name和age属性。

为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class实例能添加的属性

```python
class Student():
    __slots__ = ('name', 'age') # 用tuple来定义允许绑定的属性名称
```

使用`__slots__`要注意，`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。

除非在子类中也定义`__slots__`,这样，子类允许定义的属性就是自身的`__slots__`加上父类的`__slots__`。

#### 使用@property

在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是没办法检查参数，导致可以把成绩随便改。

这显然不合逻辑。为了限制属性的范围，可以通过set方法来设置，通过get方法来取得ㅈ，这样，在set方法里，就可以检查参数：

```python
class Student:
    
    def get_score(self):
        return self._score
    
    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError("score must between 0~100!")
        self._score = value
```

但是，上面的调用方法略显复杂，没有直接用属性那么简单

所以 :arrow_forward: 检查参数 + 属性访问 的方法：

装饰器（decorator）可以给函数动态加上功能，对于类的方法，装饰器一样起作用。

Python内置的`@property` 装饰器就负责把一个方法变成属性调用：

```python
class Student:
    
    @property
    def score(self):
        return self._score
    
    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError("score must be an integer!")
        if value < 0 or value > 100:
            raise ValueError("score must between 1~100!")
         self._score = value
```

把一个getter方法变成属性，只需要加上`@property`就可以了，此时，`@property` 本身又创建了另一个装饰器`@score.setter`，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：

注意到这个神奇的`@property`，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法实现的。

还可以定义**只读属性**，只定义getter方法，不定义setter方法就是一个只读属性：

```python
class Student:
    
    @property
    def birth(self):
        reurn self._birth
        
    @birth.setter
    def birth(self, value):
        self._birth = value
        
    @property
    def age(self):
        return 2018 - self._brith
```

上面的birth是可读写属性，而age就是一个只读属性，**因为age可以根据birth和当前时间计算出来**

##### 小结

`@property`广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性

#### 多重继承

通过多重继承，一个子类就可以同时获得多个父类的所有功能

```python
class Runnable:
    def run(self):
        print('Running...')
        
class Flyable:
    def fly(self):
        print('Flying...')
        
class Dog(Mammal, Runnable):
    pass
```

在设计类的继承关系时，通常，主线都是单一继承下来的，例如，`Ostrich`继承自`Bird`。但是，如果需要”混入“额外的功能，通过多重继承就可以实现。这种设计通常称之为MixIn

为了更好地看出继承关系，我们バRunnable和Flyable改为RunnableMixIn和FlyableMixIn，一个类可以同时拥有好几个MixIn

```python
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
```

Python自带了`TCPServer`和`UDPServer`这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由`ForkingMixIn`和`ThreadingMixIn`提供。

比如，编写一个多进程模式的TCP服务：

```python
class MyTCPServer(TCPServer, ForkingMixIn):
    pass
```

也就是说，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。

##### 小结

用于Python允许使用多重继承，因此，MixIn是一种常见的设计。

只允许单一继承的语言（如Java）不能使用MinIn的设计。

#### 定制类

`__len__()`方法是为了让class作用于`len()`函数

##### `__str__`

直接显示变量调用的是`__repr__()`，不是`__str__()`，两者的区别是`__str__()`返回的是用户看到的字符串，而`__repr__()`返回程序开发者看到的字符串，也就是说`__repr__()`是为调试服务的

解决办法是重写`__repr__()`,但是因为`__str__()`和`__repr__()`同行代码一样，所以可以

```python
__repr__ = __str__
```



##### `__iter__`

如果一个类想被用于`for...in`循环，类似list或tuple那样，就必须实现一个`__iter__()`方法。该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的`__next__()`方法拿到循环的下一个值，直到遇到`StopIteration`错误时退出循环

```python
class Fib:
    def __init__(self):
        self.a, self.b = 0, 1	# 初始化两个计数器a, b
        
    def __iter__(self):
        return self    # 实例本身就是迭代对象，故返回自己
    
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b
        if self.a > 10000:
            raise StopIteration()
        return self.a
```

##### `__getitem__`

Fib 实例虽然能作用于for循环，看起来和list 有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：

要表现得像list那样按照下标取出元素，需要实现`__getitem__()`方法

```python
class Fib:
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n)
        	a, b = b, a + b
        return a
        
```

但是list有个神奇的切片方法：

```python
>>>list(range(100))[5:10]
[5,6,7,8,9]
```

对于Fib却报错。原因是`__getitem__()`传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：

```python
class Fib:
    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice):
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a, b = b, a +b
            return L
# 但没有对step参数作处理，也没有对负数作处理
```

如果把对象看成dict，`__getitem__`的参数也可能是一个可以作key的对象，例如str。

与之对应的是`__setitem__()`方法，把对象视作list或dict来对集合赋值。

最后，还有一个`__delitem__()`方法，用于删除某个元素。

总之，通过上面的方法，我们自己定义的类表现的和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。

##### `__getattr__`

正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。会报一个AttributeError

要避免这个错误，除了可以加上缺失的属性之外，还可以写一个`__getattr__()`方法，动态返回一个属性。

```python
class Student:
    def __init__(self):
        self.name = 'dddd'
    def __getattr__(self, attr):
        if attr == 'age':
            return lambda: 25
       
>>>s = Student()
>>>s.name
'ddd'
>>>s.age()
25
```

注意，只有在没有找到属性的情况下，才调用`__getattr__`,已有的属性，比如name，不会在其中查找

其他任意调用都会返回None，这是因为我们定义的`__getattr__`默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出`AttributeError`的错误

```python
class Student:
    if attr == 'age':
        return lambda: 25
    raise AttributeError('\'Student\' object has no attribute \'%s\' % attr)
```

这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段

这种完全动态调用的特性的作用是：可以针对完全动态的情况作调用：

链式调用：

```python
class Chain:
    def __init__(self, path=''):
        self._path = path
        
    def __getattr__(self, path):
        return Chain('%s%s' % (self._path, path))
    
    
```



##### `__call__`

一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用`instance.method()`来调用。也可以直接在实例本身上调用。

任何类，只需要定义一个`__call__()`方法，就可以直接对实例进行调用

```python
class Student:
    def __init__(self, name):
        self.name = name
    
    def __call__(self):
        print("my name is {}".format(self.name))
```

调用方式如下：

```python
>>>s = Student('gtest')
>>>s() #self参数不要传入
```

`__call__()`还可以定义参数。

对实例进行直接调用就好比对一个函数进行调用一样，所以可以完全把对象看成函数，把函数看成对象。



#### 使用枚举类

定义常量时，一个办法是用大写变量通过整数来定义：

```python
JAN = 1
FEB = 2
```

好处是简单，缺点是类型是int，并且仍然是变量。

更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了`Enum`类来实现这个功能：

```python
from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar','Apr', 'May', 'Jun'))
```

这样我们就获得了`Month`类型的枚举类，可以直接使用`Month.Jan`来引用一个常量，或枚举它所有成员：

```python
for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value)
```

`value`属性是自动赋给成员的int常量，默认从1开始计数。

如果需要更精确地控制枚举类型，可以从`Enum`派生出自定义类：

```python
from enum import Enum, unique

@unique    # unique装饰器可以帮助我们检查有没有重复值
class Weekday(Enum):
    Sun = 0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
```

访问这些枚举类型可以有若干种方法：

```python
# 1.可以通过成员名称引用枚举常量
>>> print(Weekday.Sun)
Weekday.Sun
# 1.1 也可以通过key的方式来引用，因为是一个有序字典
>>> print(Weekday['Fri'])
Weekday.Fir
# 2. 也可以通过value来获得枚举常量
>>> print(Weekday(1))
Weekday.Mon
```

#### 补充枚举类型

*原文链接：https://segmentfault.com/a/1190000017327003*

##### 起步

Python的原生类型中并不包含枚举类型。为了提供更好的解决方案，Python通过PEP 435 在3.4 版本中添加了`enum`标准库。

枚举类型可以看作是一种标签或是一系列常量的组合，通常用于表示某些特定的有限集合，例如星期、月份、状态等。在没有专门提供枚举类型的时候一般通过字典或类来实现：

```python
Color = {
    'RED': 1,
    'Green': 2,
    'BLUE': 3,
}

class Color:
    RED = 1
    GREEN = 2
    BLUE = 3
```

这种来实现枚举如果小心翼翼地使用当然没什么问题，毕竟是一种妥协的解决方案。它的隐患在于可以被修改。

#### 使用 Enum

更好的方式是使用标准库提供的`Enum`类型，官方库值得信赖。3.4之前的版本也可以通过`pip install enum` 下载支持的库。 简单的示例：

```python
from enum import Enum
class Color(Enum):
    red = 1
    green = 2
    blue = 3
```

枚举成员有值（默认可重复），枚举成员具有友好的字符串表示：

```python
>>> print(Color.red)
Color.red
>>>print(repr(Color.red))
<Color.red: 1>
>>> type(Color.red)
<Enum 'Color'>
>>> isinstance(Color.green, Color)
True
```

枚举类型不可实例化，不可更改。

#### 定义枚举

定义枚举时，成员名不允许重复

```python
class Color(Enum):
    red = 1
    green = 2
    red = 3    # TypeError: Attempted to reuse key: 'red'
```

成员值允许相同，第二个成员的名称被视作第一个成员的别名

#### 使用元类

-------使用元类的就不看了-----------------

#### 补充一部分静态方法类方法的

##### property

##### 静态方法

通常情况下，在类中定义的所有函数都是对象的绑定方法，对象在调用绑定方法时会自动将自己作为第一个参数传递给方法的第一个参数。

除此之外还有两种常见的方法：静态方法和类方法，二者视为类量身定制的，但是实例非要使用，也不会报错。

是一种普通函数，位于类定义的命名空间中，不会对任何实例进行操作，Python为我们内置了函数staticmethod来把类中的函数定义成静态方法

```python
class Foo:
    def spam(x,y,z):	# 类中的一个函数，x和self是一样的
        print(x,y,z)
    spam=staticmethod(spam)		# 把spam函数做成静态方法
```

基于之前所学装饰器的知识，`@staticmethod`等同于`spam=staticmethod(spam)`,于是：

```python
class Foo:
    @staticmethod
    def spam(x,y,z):
        print(x,y,z)
        
# 使用展示
print(type(Foo.spam))  #类型本质就是函数
Foo.spam(1,2,3)		#调用函数应该有几个参数就传几个参数

f1 = Foo()
f1.spam(3,3,3)	# 实例也可以使用，但通常静态方法都是给类使用的，实例在使用时丧失了自动传值的机制

>>>输出结果为
<class 'function'>
1 2 3
3 3 3
```

应用场景：编写类时需要采用很多不同的方式来创建实例，只靠一个`__init__`不够，此时可以靠静态方法

```python
class Date:
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day
    @staticmethod
    def now():	#用Date.now()的形式去产生实例，该实例用的是当前时间
        t = time.localtime()	#获取结构化的时间格式
        return Date(t.tm_year, t.tm_month, t.tm_day)
    @staticmethod
    def tomorrow():
        t = time.localtime(time.time() + 86400)
        return Date(t.tm_year,t.tm_month,t.tm_day)
    
```

##### 类方法

类方法是给类用的，类在使用时会将类本身当做参数

##### `__str__`的用法

----

## Python入门指南

### 9.类

Python的类机制通过最小的新语法和语义在语言中实现了类。它是C++ 或者Modula-3 语言中类机制的混合。就像模块一样，Python的类并没有在用户和定义之间设立绝对的屏障，而是依赖于用户不去“强行闯入定义”的优雅。另一方面，类的大多数重要特性都被完整的保留下来：

类继承机制允许多重继承，派生类可以覆盖基类中的任何方法或类，可以使用相同的方法名称调用基类的方法。对象可以包含任意数量的私有数据。

用C++术语来讲，所有的类成员（包括数据成员）都是公有的，所有的成员函数都是虚的。用Modula-3的术语来讲，在成员方法中没有简便的方式引用对象的成员：方法函数在定义时需要以引用的对象作为第一个参数，调用时则会隐式引用对象。像在Smalltalk中一个，类也是对象。这就提供了导入和重命名语义。不像C++和Modula-3中那样，大多数带有特殊语法的内置操作符（算法运算符、下标等）都可以针对类的需要重新定义。

#### 9.1 术语相关

对象具有特性，并且多个名称（在多个作用域中）可以绑定在同一个对象上。在其他语言中被称为别名。在对Python的第一印象中，这通常会被武略，并且当处理不可变基础类型（数字、字符串、元组）时可以被放心的忽略。但是，在调用列表、字典这类可变对象，或者大多数程序外部类型（文件、窗体等）描述实体时，别名对Python代码的语义便具有（有意而为）影响。这通常有助于程序的优化，因为在某些方面别名表现的就像是指针。例如，你可以轻易的传递一个对象，因为通过继承只是传递一个指针。并且如果一个方法修改了一个作为参数传递的对象，调用者可以接收这一变化--着笑出了

----

## 像计算机科学家一样思考

### 第15章 类和对象

#### 15.1 用户定义类型

```python
class Point(Object):
    """Represents a point in 2-D space."""
```

Point是在程序顶层定义的，它的“全名”是`__main__.Point`

类对象像一个创建对象的工厂。要新建一个Point对象，可以把Point当做函数来调用

```python
>>> blank = Point()
>>> print(blank)
<__main__.Point instance at 0xxxxxxx>
```

返回值是到一个Point对象的引用，我们将它赋值给变量blank。新建一个对象的过程称为实例化，而对象是这个类的一个实例。

当打印一个实例时，Python会告诉你ta所属的类型，以及存储在内存中的位置（前缀0x表示后面的数字是16进制的）

#### 15.2 属性

可以使用句点表示法来给实例赋值：

```python
>>> blank.x = 3.0
>>> blank.y = 4.0
```

我们是将值赋给一个对象的有命名的元素，这些元素称为属性。

变量blank引用了一个Point对象，它包含了两个属性。每个属性引用一个浮点数。

##### 练习15-1

```python
def distance_between_points(p1, p2):
    return math.sqrt((p1.x-p2.x)**2 +(p1.y-p2.y)**2)
```

#### 15.3 矩形

假设你在设计一个表达矩形的类。你会用什么属性来指定一个矩形的位置和尺寸呢？

可以忽略角度，为了简单起见，嘉定矩形不是垂直的就是水平的

最少有以下两种可能：

* 你可以指定一个矩形的一个角落（或者中心点），宽度以及高度
* 你可以指定两个相对的角落

```python
class Rectangle:
    """Represents a rectangle.
    
    attributes: width, height, corner.
    """
```

作为另一个对象的属性存在的对象是内嵌的

#### 15.4 作为返回值的实例

函数可以返回实例。例如，find_center接收Rectangle对象作为参数，并返回一个Point对象，包含这个Rectangle的中心点的坐标：

```python
def find_center(rect):
    p = Point()
    p.x = rect.corner.x + rect.width/2.0
    p.y = rect.corner.y + rect.height/2.0
    return p
```

#### 15.5 对象是可变的

可以通过给一个对象的某个属性赋值来修改它的状态。

也可以编写函数来修改对象。

##### 练习 15-2

```python
def move_rectangle(rect, dx, dy):
    rect.corner.x += dx
    rect.corner.y += dy
    
```

#### 15.6 复制

别名的使用有时候会让程序更难阅读，因为一个地方的修改可能会给其他地方带来意想不到的变化。要跟踪掌握所有引用到一个给定对象的变量非常困难

使用别名的常用替代方案是复制对象。





### 第16章 类和函数

#### 16.1 时间

我们定义一个叫做Time的类，用于记录一天里的时间。类定义如下：

```python
class Time:
    """Represents the time of day.
    attributes: hour, minute, second
    """
```

























