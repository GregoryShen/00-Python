## Python编程：从入门到实践

类：表示现实世界中的事物和情景

基于这些类来创建对象。

编写类时：定义一大类对象都有的通用行为。

基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。

根据类来创建对象被称为<u>**实例化**</u>，这让我们能够使用类的实例。

1. 创建类
   1. 方法`__init__()`
   2. 在Python 2.7 中创建类（略）

> 为何必须在方法定义中包含形参self呢？
>
> 因为Python调用这个`__init__()`方法来创建Dog实例时，将自动传入实参self。
>
> 事实上每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。
>
> 以self为前缀的变量都可以供勒种的所有方法使用，我们还可以通过类的任何实例来访问这些变量。
>
> self.name = name 获取存储在形参name中的值，并将其存储到变量name中，然后**该变量被关联到当前创建的实例。**
>
> 像这样可以通过实例访问的变量称为**<u>属性</u>**

2. 根据类创建实例

可将类视为有关如何创建实例的说明。Dog类是一系列说明，让Python知道如何创建表示特定小狗的实例。

* 访问属性：通过句点表示法

```python
my_dog.name
```

这种语法演示了Python是如何获取属性的值。在这里，Python先找到实例my_dog, 再查找与这个实例相关联的属性name。在Dog类中引用这个属性时，使用的是`self.name` 。

`title()`函数的作用是将首字母大写。

`str()`将age的值6转换为字符串

* 调用方法

根据Dog类创建实例后，就可以使用句点法来调用Dog类中的任何方法

```python
my_dog = Dog('willie', 6)
my_dog.sit()
my_dog.roll_over()
```

* 创建多个实例

你可以按需求根据一个类创建任意数量的实例，条件是将每个实例都存储在不同的变量中，或占用列表或字典不同的位置。

----

使用类＆实例

可以使用类来模拟现实世界中的很多情景。

类编写好后，你的大部分时间都将花在使用根据类创建的实例上。

你需要执行的一个重要任务是修改实例的属性。

可以直接修改实例的属性，也可以编写方法以特定的方式进行修改。

**修改属性的值**

三种不同方式：

1. 直接通过实例进行修改

2. 通过方法进行设置

   可以在方法中进行设置，在修改属性前检查指定的读数是否合理，如果新指定的里程大于等于原来的

   里程（self.odometer_reading)，就将里程表读数改为新指定的里程；否则就发出警告，指出不能将里程表往回拨

3. 通过方法进行递增（增加特定的值）

   可以轻松的修改这个方法，以禁止增量为负值，从而防止有人利用它来回拨里程表

**注意**：可以使用2、3方法来控制用户修改属性值，但能够访问程序的人都可以通过直接访问属性来将里程表修改为任何值，要确保安全，畜类进行类似前面的基本检查外，还需要特别注意细节。

#### 继承

----

编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可以使用**继承**。

一个类继承另一个类时，它将自动获得另一个类的所有属性和方法：原有的类称为父类，新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。

##### 子类的方法`__init__()`

创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法`__init__()`需要父类施以援手。

##### 重写父类方法

对于父类的方法，只要它不符合子类模拟的实物的行为，都可以对其进行重写。为此，可以在子类中定义这样的方法，即它与要重写的方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。

使用继承时，可让子类保留从父类那里继承而来的精华，并剔除不需要的糟粕。

##### 将实例用作属性

使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。可以将大型类拆分成多个协同工作的小类

##### 模拟实物

现实世界的建模方法并没有对错之分。有些效率更高，但要找出效率最高的表示法，需要经过一定的实践。

#### 导入类

随着你不断地给类添加功能，文件可能变得很长，即使你妥善地使用了继承亦如此。为遵循Python的总体理念，应让文件尽可能整洁。为在这方面提供帮助，Python允许你将类存储在模块中，然后在主程序中导入所需的模块。

##### 导入单个类

导入类是一种有效的编程方式。如果在这个程序中包含了整个Car类，就会很长。通过将这个类移动到一个模块中，并导入该模块，你依然可以使用其所有功能，但主程序文件变得整洁而易读了。

这还能让你将大部分逻辑存储在独立的文件中：确定类像你希望的那样工作后，你就可以不管

这些文件，而专注于主程序的高级逻辑了。

##### 在一个模块中存储多个类

同一个模块中的类应该存在某种相关性，但可根据需要在一个模块中存储任意数量的类。

类Battery和ElectricCar都可以帮助模拟汽车，因此将它们都加入模块`car.py`

##### 从一个模块中导入多个类

可以根据需要在程序文件中导入任意数量的类。

##### 导入整个模块

可以导入整个模块，再使用句点法表示访问需要的类。由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。

```python
import car
```

我们使用语法`module_name.class_name`访问需要的类。

##### 导入模块中所有的类

要导入模块中的每个类，可以使用：

```python
from module_name import *
```

不推荐使用这种导入方式，原因：

1. 如果只要看一下文件开头的import语句，就能清楚地知道程序使用了哪些类，将大有裨益，但这种方式没有明确地指出你使用了模块中的哪些类
2. 

----

## 廖雪峰课程

### 面向对象编程

OOP是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。

面向对象把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中类的概念。

面向对象的设计思想是抽象出class，根据class创建Instance。

面向对象的抽象程度又比函数要高，因为一个class既包含数据，又包含操作数据的方法。

#### 类和实例

类是抽象的模板，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自

的数据可能不同。

<u>**可以给实例变量绑定属性**</u>

由于类可以起到模板的作用，因此，可以在创建实例的时候，把属性绑定上去

`__init__`方法的第一个参数永远是self， 表示创建的实例本身， 因此，在`__init__`方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身

##### 数据封装

面向对象编程的一个重要特点就是数据封装。

我们可以通过函数来访问这些数据，但是，既然实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在类内部定义访问数据的函数，这样，就把“数据”给封装起来了。

这些封装数据的函数是和类本身关联起来的，我们称之为类的方法：

我们从外部看类，就只需要知道，创建实例需要给出两个属性值，而如何打印，是在类内部定义的，这些数据和逻辑被"封装"起来了，调用很容易，但却不用知道内部实现的细节。

封装的另一个好处是可以给类增加新的方法

方法就是与实力绑定的函数，和普通函数不同，方法可以直接访问实例的数据

通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节

和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然他们都是同一个类的不同实例，但拥有的变量名称都可能不同

#### 访问限制

在class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的<u>**方法**</u><u>*[这里我们说的是method]</u>*来操作数据，这样，就隐藏了内部的复杂逻辑。

但是，还是可以直接通过直接修改属性的方式来修改值。

如果要让内部属性不被外部访问，可以把属性名称前加两个下划线。在Python中，实例的变量名如果以

双下划线开头，就变成了一个私有变量，只有内部可以访问，外部不能访问。

（实在想访问的话可以通过 `实例变量._类名__属性名`来访问）

不过强烈不建议这么干，因为不同版本的Python解释器可能会把`__属性名`改成不同的变量名

但是如果外部代码要获取属性值怎么办，可以给类增加get方法

如果要修改属性值怎么办，增加set方法

**这种通过方法来修改的好处：可以对参数做检查，避免传入无效的参数**

需要注意的是，在Python中，变量名类似`__xxx__`是特殊变量，可以直接访问，不是私有变量。

单下划线的，这么骚气的变量命名。这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”

#### 继承和多态

当子类和父类都存在相同的方法时，我们说，子类方法覆盖了父类方法，在代码运行的时候，总是回调用子类的方法，这就是**多态**

当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型一样。

判断一个变量是否是某个类型可以用`isinstance()`判断

```python
isinstance(要判断的东西，想要匹配的类型)
```

在继承关系中，如果一个实例的数据类型是某个子类，那他的数据类型也可以被看做是父类。反之不行。

```python
def run_twice(animal):
    animal.run()
    animal.run()
```



#### 获取对象信息

判断对象类型，用`type()`函数

`type()`函数返回的是对应的class类型，如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同：

判断基本数据类型可以直接写`int`,`str`等，如果要判断一个对象是否是函数，可以用types模块中定义的常量：

对于class的继承关系来说，使用`type()`就很不方便。我们要判断class的类型，可以使用`isinstance()`函数。

`isinstance()`判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。

能用type()判断的基本类型也可以用isinstance()判断

并且还以判断一个变量是否是某些类型中的一种：

```python
isinstance([1,2,3], (list, tuple))
```

总是优先使用`isinstance()`判断类型，可以将指定类型及其子类“一网打尽”



#### 实力属性和类属性

因为是动态语言，根据类创建的实例可以任意绑定属性。

给实例绑定属性的方法是通过实例变量，或者通过`self`变量



如果类本身要绑定一个属性，可以直接在class中定义属性，这种属性是类属性，归类所有

当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到



在编写程序时，不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的是类属性

### 面向对象高级编程

数据封装、继承和多态只是OOP中最基础的3个概念。

还有多重继承、定制类、元类等概念

#### 使用`__slots__`

给实例绑定一个方法：

```python
def set_age(self, age):
    self.age = age
    
from types import MethodType
s.set_age = MethodType(set_age, s)
```

但是 给一个实例绑定的方法，对另一个实例是不起作用的。为了给所有实例都绑定方法，可以给class绑定方法：

```python
def set_score(self, score):
    self.score = score
Student.set_score = set_score
```

通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。

##### 使用`__slots__`

如果我们想要限制实例的属性，比如，只允许对Student实例添加name和age属性。

为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class实例能添加的属性

```python
class Student():
    __slots__ = ('name', 'age') # 用tuple来定义允许绑定的属性名称
```

使用`__slots__`要注意，`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。

除非在子类中也定义`__slots__`,这样，子类允许定义的属性就是自身的`__slots__`加上父类的`__slots__`。

#### 使用@property

在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是没办法检查参数，导致可以把成绩随便改。

这显然不合逻辑。为了限制属性的范围，可以通过set方法来设置，通过get方法来取得ㅈ，这样，在set方法里，就可以检查参数：

```python
class Student:
    
    def get_score(self):
        return self._score
    
    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError("score must between 0~100!")
        self._score = value
```

但是，上面的调用方法略显复杂，没有直接用属性那么简单

所以 :arrow_forward: 检查参数 + 属性访问 的方法：

装饰器（decorator）可以给函数动态加上功能，对于类的方法，装饰器一样起作用。

Python内置的`@property` 装饰器就负责把一个方法变成属性调用：

```python
class Student:
    
    @property
    def score(self):
        return self._score
    
    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError("score must be an integer!")
        if value < 0 or value > 100:
            raise ValueError("score must between 1~100!")
         self._score = value
```

把一个getter方法变成属性，只需要加上`@property`就可以了，此时，`@property` 本身又创建了另一个装饰器`@score.setter`，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：

注意到这个神奇的`@property`，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法实现的。

还可以定义**只读属性**，只定义getter方法，不定义setter方法就是一个只读属性：

```python
class Student:
    
    @property
    def birth(self):
        reurn self._birth
        
    @birth.setter
    def birth(self, value):
        self._birth = value
        
    @property
    def age(self):
        return 2018 - self._brith
```

上面的birth是可读写属性，而age就是一个只读属性，**因为age可以根据birth和当前时间计算出来**

##### 小结

`@property`广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性

#### 多重继承

通过多重继承，一个子类就可以同时获得多个父类的所有功能

```python
class Runnable:
    def run(self):
        print('Running...')
        
class Flyable:
    def fly(self):
        print('Flying...')
        
class Dog(Mammal, Runnable):
    pass
```

在设计类的继承关系时，通常，主线都是单一继承下来的，例如，`Ostrich`继承自`Bird`。但是，如果需要”混入“额外的功能，通过多重继承就可以实现。这种设计通常称之为MixIn

为了更好地看出继承关系，我们バRunnable和Flyable改为RunnableMixIn和FlyableMixIn，一个类可以同时拥有好几个MixIn

```python
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
```

Python自带了`TCPServer`和`UDPServer`这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由`ForkingMixIn`和`ThreadingMixIn`提供。

比如，编写一个多进程模式的TCP服务：

```python
class MyTCPServer(TCPServer, ForkingMixIn):
    pass
```

也就是说，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。

##### 小结

用于Python允许使用多重继承，因此，MixIn是一种常见的设计。

只允许单一继承的语言（如Java）不能使用MinIn的设计。

#### 定制类

`__len__()`方法是为了让class作用于`len()`函数

##### `__str__`

直接显示变量调用的是`__repr__()`，不是`__str__()`，两者的区别是`__str__()`返回的是用户看到的字符串，而`__repr__()`返回程序开发者看到的字符串，也就是说`__repr__()`是为调试服务的

解决办法是重写`__repr__()`,但是因为`__str__()`和`__repr__()`同行代码一样，所以可以

```python
__repr__ = __str__
```



##### `__iter__`

如果一个类想被用于`for...in`循环，类似list或tuple那样，就必须实现一个`__iter__()`方法。该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的`__next__()`方法拿到循环的下一个值，直到遇到`StopIteration`错误时退出循环

```python
class Fib:
    def __init__(self):
        self.a, self.b = 0, 1	# 初始化两个计数器a, b
        
    def __iter__(self):
        return self    # 实例本身就是迭代对象，故返回自己
    
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b
        if self.a > 10000:
            raise StopIteration()
        return self.a
```

##### `__getitem__`

Fib 实例虽然能作用于for循环，看起来和list 有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：

要表现得像list那样按照下标取出元素，需要实现`__getitem__()`方法

```python
class Fib:
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n)
        	a, b = b, a + b
        return a
        
```

但是list有个神奇的切片方法：

```python
>>>list(range(100))[5:10]
[5,6,7,8,9]
```

对于Fib却报错。原因是`__getitem__()`传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：

```python
class Fib:
    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice):
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a, b = b, a +b
            return L
# 但没有对step参数作处理，也没有对负数作处理
```

如果把对象看成dict，`__getitem__`的参数也可能是一个可以作key的对象，例如str。

与之对应的是`__setitem__()`方法，把对象视作list或dict来对集合赋值。

最后，还有一个`__delitem__()`方法，用于删除某个元素。

总之，通过上面的方法，我们自己定义的类表现的和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。

##### `__getattr__`

正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。会报一个AttributeError

要避免这个错误，除了可以加上缺失的属性之外，还可以写一个`__getattr__()`方法，动态返回一个属性。

```python
class Student:
    def __init__(self):
        self.name = 'dddd'
    def __getattr__(self, attr):
        if attr == 'age':
            return lambda: 25
       
>>>s = Student()
>>>s.name
'ddd'
>>>s.age()
25
```

注意，只有在没有找到属性的情况下，才调用`__getattr__`,已有的属性，比如name，不会在其中查找

其他任意调用都会返回None，这是因为我们定义的`__getattr__`默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出`AttributeError`的错误

```python
class Student:
    if attr == 'age':
        return lambda: 25
    raise AttributeError('\'Student\' object has no attribute \'%s\' % attr)
```

这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段

这种完全动态调用的特性的作用是：可以针对完全动态的情况作调用：

链式调用：

```python
class Chain:
    def __init__(self, path=''):
        self._path = path
        
    def __getattr__(self, path):
        return Chain('%s%s' % (self._path, path))
    
    
```



##### `__call__`

一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用`instance.method()`来调用。也可以直接在实例本身上调用。

任何类，只需要定义一个`__call__()`方法，就可以直接对实例进行调用

```python
class Student:
    def __init__(self, name):
        self.name = name
    
    def __call__(self):
        print("my name is {}".format(self.name))
```

调用方式如下：

```python
>>>s = Student('gtest')
>>>s() #self参数不要传入
```

`__call__()`还可以定义参数。

对实例进行直接调用就好比对一个函数进行调用一样，所以可以完全把对象看成函数，把函数看成对象。



#### 使用枚举类

定义常量时，一个办法是用大写变量通过整数来定义：

```python
JAN = 1
FEB = 2
```

好处是简单，缺点是类型是int，并且仍然是变量。

更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了`Enum`类来实现这个功能：

```python
from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar','Apr', 'May', 'Jun'))
```

这样我们就获得了`Month`类型的枚举类，可以直接使用`Month.Jan`来引用一个常量，或枚举它所有成员：

```python
for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value)
```

`value`属性是自动赋给成员的int常量，默认从1开始计数。

如果需要更精确地控制枚举类型，可以从`Enum`派生出自定义类：

```python
from enum import Enum, unique

@unique    # unique装饰器可以帮助我们检查有没有重复值
class Weekday(Enum):
    Sun = 0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
```

访问这些枚举类型可以有若干种方法：

```python
# 1.可以通过成员名称引用枚举常量
>>> print(Weekday.Sun)
Weekday.Sun
# 1.1 也可以通过key的方式来引用，因为是一个有序字典
>>> print(Weekday['Fri'])
Weekday.Fir
# 2. 也可以通过value来获得枚举常量
>>> print(Weekday(1))
Weekday.Mon
```

#### 补充枚举类型

*原文链接：https://segmentfault.com/a/1190000017327003*

##### 起步

Python的原生类型中并不包含枚举类型。为了提供更好的解决方案，Python通过PEP 435 在3.4 版本中添加了`enum`标准库。

枚举类型可以看作是一种标签或是一系列常量的组合，通常用于表示某些特定的有限集合，例如星期、月份、状态等。在没有专门提供枚举类型的时候一般通过字典或类来实现：

```python
Color = {
    'RED': 1,
    'Green': 2,
    'BLUE': 3,
}

class Color:
    RED = 1
    GREEN = 2
    BLUE = 3
```

这种来实现枚举如果小心翼翼地使用当然没什么问题，毕竟是一种妥协的解决方案。它的隐患在于可以被修改。

#### 使用 Enum

更好的方式是使用标准库提供的`Enum`类型，官方库值得信赖。3.4之前的版本也可以通过`pip install enum` 下载支持的库。 简单的示例：

```python
from enum import Enum
class Color(Enum):
    red = 1
    green = 2
    blue = 3
```

枚举成员有值（默认可重复），枚举成员具有友好的字符串表示：

```python
>>> print(Color.red)
Color.red
>>>print(repr(Color.red))
<Color.red: 1>
>>> type(Color.red)
<Enum 'Color'>
>>> isinstance(Color.green, Color)
True
```

枚举类型不可实例化，不可更改。

#### 定义枚举

定义枚举时，成员名不允许重复

```python
class Color(Enum):
    red = 1
    green = 2
    red = 3    # TypeError: Attempted to reuse key: 'red'
```

成员值允许相同，第二个成员的名称被视作第一个成员的别名

#### 使用元类

-------使用元类的就不看了-----------------

#### 补充一部分静态方法类方法的

##### property

##### 静态方法

通常情况下，在类中定义的所有函数都是对象的绑定方法，对象在调用绑定方法时会自动将自己作为第一个参数传递给方法的第一个参数。

除此之外还有两种常见的方法：静态方法和类方法，二者视为类量身定制的，但是实例非要使用，也不会报错。

是一种普通函数，位于类定义的命名空间中，不会对任何实例进行操作，Python为我们内置了函数staticmethod来把类中的函数定义成静态方法

```python
class Foo:
    def spam(x,y,z):	# 类中的一个函数，x和self是一样的
        print(x,y,z)
    spam=staticmethod(spam)		# 把spam函数做成静态方法
```

基于之前所学装饰器的知识，`@staticmethod`等同于`spam=staticmethod(spam)`,于是：

```python
class Foo:
    @staticmethod
    def spam(x,y,z):
        print(x,y,z)
        
# 使用展示
print(type(Foo.spam))  #类型本质就是函数
Foo.spam(1,2,3)		#调用函数应该有几个参数就传几个参数

f1 = Foo()
f1.spam(3,3,3)	# 实例也可以使用，但通常静态方法都是给类使用的，实例在使用时丧失了自动传值的机制

>>>输出结果为
<class 'function'>
1 2 3
3 3 3
```

应用场景：编写类时需要采用很多不同的方式来创建实例，只靠一个`__init__`不够，此时可以靠静态方法

```python
class Date:
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day
    @staticmethod
    def now():	#用Date.now()的形式去产生实例，该实例用的是当前时间
        t = time.localtime()	#获取结构化的时间格式
        return Date(t.tm_year, t.tm_month, t.tm_day)
    @staticmethod
    def tomorrow():
        t = time.localtime(time.time() + 86400)
        return Date(t.tm_year,t.tm_month,t.tm_day)
    
```

##### 类方法

类方法是给类用的，类在使用时会将类本身当做参数

##### `__str__`的用法

----

## Python入门指南

### 9.类

Python的类机制通过最小的新语法和语义在语言中实现了类。它是C++ 或者Modula-3 语言中类机制的混合。就像模块一样，Python的类并没有在用户和定义之间设立绝对的屏障，而是依赖于用户不去“强行闯入定义”的优雅。另一方面，类的大多数重要特性都被完整的保留下来：

类继承机制允许多重继承，派生类可以覆盖基类中的任何方法或类，可以使用相同的方法名称调用基类的方法。对象可以包含任意数量的私有数据。

用C++术语来讲，所有的类成员（包括数据成员）都是公有的，所有的成员函数都是虚的。用Modula-3的术语来讲，在成员方法中没有简便的方式引用对象的成员：方法函数在定义时需要以引用的对象作为第一个参数，调用时则会隐式引用对象。像在Smalltalk中一个，类也是对象。这就提供了导入和重命名语义。不像C++和Modula-3中那样，大多数带有特殊语法的内置操作符（算法运算符、下标等）都可以针对类的需要重新定义。

#### 9.1 术语相关

对象具有特性，并且多个名称（在多个作用域中）可以绑定在同一个对象上。在其他语言中被称为别名。在对Python的第一印象中，这通常会被武略，并且当处理不可变基础类型（数字、字符串、元组）时可以被放心的忽略。但是，在调用列表、字典这类可变对象，或者大多数程序外部类型（文件、窗体等）描述实体时，别名对Python代码的语义便具有（有意而为）影响。这通常有助于程序的优化，因为在某些方面别名表现的就像是指针。例如，你可以轻易的传递一个对象，因为通过继承只是传递一个指针。并且如果一个方法修改了一个作为参数传递的对象，调用者可以接收这一变化--着笑出了

----

## 像计算机科学家一样思考

### 第15章 类和对象

#### 15.1 用户定义类型

```python
class Point(Object):
    """Represents a point in 2-D space."""
```

Point是在程序顶层定义的，它的“全名”是`__main__.Point`

类对象像一个创建对象的工厂。要新建一个Point对象，可以把Point当做函数来调用

```python
>>> blank = Point()
>>> print(blank)
<__main__.Point instance at 0xxxxxxx>
```

返回值是到一个Point对象的引用，我们将它赋值给变量blank。新建一个对象的过程称为实例化，而对象是这个类的一个实例。

当打印一个实例时，Python会告诉你ta所属的类型，以及存储在内存中的位置（前缀0x表示后面的数字是16进制的）

#### 15.2 属性

可以使用句点表示法来给实例赋值：

```python
>>> blank.x = 3.0
>>> blank.y = 4.0
```

我们是将值赋给一个对象的有命名的元素，这些元素称为属性。

变量blank引用了一个Point对象，它包含了两个属性。每个属性引用一个浮点数。

##### 练习15-1

```python
def distance_between_points(p1, p2):
    return math.sqrt((p1.x-p2.x)**2 +(p1.y-p2.y)**2)
```

#### 15.3 矩形

假设你在设计一个表达矩形的类。你会用什么属性来指定一个矩形的位置和尺寸呢？

可以忽略角度，为了简单起见，嘉定矩形不是垂直的就是水平的

最少有以下两种可能：

* 你可以指定一个矩形的一个角落（或者中心点），宽度以及高度
* 你可以指定两个相对的角落

```python
class Rectangle:
    """Represents a rectangle.
    
    attributes: width, height, corner.
    """
```

作为另一个对象的属性存在的对象是内嵌的

#### 15.4 作为返回值的实例

函数可以返回实例。例如，find_center接收Rectangle对象作为参数，并返回一个Point对象，包含这个Rectangle的中心点的坐标：

```python
def find_center(rect):
    p = Point()
    p.x = rect.corner.x + rect.width/2.0
    p.y = rect.corner.y + rect.height/2.0
    return p
```

#### 15.5 对象是可变的

可以通过给一个对象的某个属性赋值来修改它的状态。

也可以编写函数来修改对象。

##### 练习 15-2

```python
def move_rectangle(rect, dx, dy):
    rect.corner.x += dx
    rect.corner.y += dy
    
```

#### 15.6 复制

别名的使用有时候会让程序更难阅读，因为一个地方的修改可能会给其他地方带来意想不到的变化。要跟踪掌握所有引用到一个给定对象的变量非常困难

使用别名的常用替代方案是复制对象。





### 第16章 类和函数

#### 16.1 时间

我们定义一个叫做Time的类，用于记录一天里的时间。类定义如下：

```python
class Time:
    """Represents the time of day.
    attributes: hour, minute, second
    """
```

## Python-面向对象(imooc)

### 第1章 课程介绍

#### 1-1 课程介绍

我们在这里谈到的面向对象,全称叫Object Oriented Programming,简称OOP,它是目前在程序开发里面应用的最主流的一种编程思想.

它把对象作为程序的基本单元,把数据和一些功能封装在里面,能够实现很好的复用性,灵活性和扩展性.

在这个课程里面将介绍以下内容,首先是面向对象的理论基础,然后用Python来实现一些面向对象的基本特性,最后我们来谈谈深入的Python面向对象的知识.

### 第2章 面向对象概念

#### 2-1 面向对象概念

首先来谈谈什么是面向对象

##### 面向对象是一种抽象

​	  在这里说的抽象是指的一种用分类的眼光来看待世界的事物的一种方法,我们需要对一些事物进行总结,需要分析它的共性.利用抽象能够大大地简化我们在实际中解决问题的难度.

面向对象的两个基本概念

* 类

* 对象

类是定义了一件事物的抽象特点,而对象是类的一个实例. 下面举个例子进行说明:

程序员本身是一个类,它把现实生活中的一个群体进行了总结和抽象;而屏幕前看视频的小伙伴每一个个体都是属于程序员这类的一个对象,对象指的是一个一个的个体而不是某一类人.

#####  面向对象的基本要素

* 属性
* 方法

首先在这里有一个程序员的类,它会需要存储一些关于它的相应的信息,这些信息就是类的属性.比如在这个例子里面,程序员的年龄、性别和身高, 除了这些属性之外,还有些功能,比如说写代码,修电脑.属性和功能组成了一个类.

在这里还需要提到面向对象的一个概念,就是封装性.因为一个程序员的功能,比如写代码,修电脑,作为外人的话你其实只知道它有这个功能,并不知道它是如何实现的.这就是封装性.

类对外暴露了功能,隐藏了具体实现细节.

##### 继承

程序员是一个相当大的群体,可以对这个群体做更细分的分类,比如一种比较常见的分法,前端程序员和后端程序员.这两个类就是从程序员这个类继承的子类.这两个子类继承了来自父类的属性和方法.我们在这里对后端程序员这个类进行更细分的划分,生成3个子类,分别是使用三种不同语言的类:PHP程序员,Java程序员和Python程序员,在这里面继承的子类有一个特性,就是在判断类型的时候除了会被认为是自己所在的类,也会被认为是他的父类,在这个例子看很好理解,比如说一名Python程序员既是后端程序员也是一名程序员,更细的分类是从属于它的父类的.

这里谈到的是单继承,在面向对象的概念里还有多继承.我们在分类的时候除了有不同的粒度还可以有不同的维度,比如说在这里的例子,继承自Python程序员和足球迷形成了一个子类叫球迷Python程序员,这与现实生活中分类是类似的,一样事物是在不同的维度下可以分别从属于不同的分类.需要说明的是多继承的特性在有一些的编程语言里面是没有得到支持的,但是在Python里面是可以进行多重继承的.

##### 多态

指的是用一个类继承的几个不同的类调用同一方法的时候会有不同的反应.套用之前的例子,我们从后端程序员这个类里面继承出来三个类,分别是使用不同语言的,它会继承来自后端程序员的一个方法`bestLanguage()`,那么它这个类的方法功能是返回它认为最好的语言.从这个类继承的三个类里面各自也会有这个方法,他们在这个类的定义里面它会重写父类这个方法,并且返回出不同的结果,这就是多态.

##### 类的特性

* 封装性
* 继承
* 多态

##### 总结

在这一节里面介绍了面向对象的一些基本概念,在后面的内容里面我们将进入实操来学习Python中的面向对象的知识.

### 第3章 Python面向对象

#### 3-1 用Python 定义类

会先介绍用Python创建类的语法,它的构造函数和析构函数,最后会用一个简单的程序的例子来讲解用Python创建类的过程

##### 定义类

```python
class ClassName:
    statement1
    ...
    statementN
```

在这里用到了关键字`class`,这个和其他很多的面向对象语言都是一样的,在`class`里定义的语句就是这个类的定义.

##### 构造函数

在之前谈到类是由属性和功能组成的,当我们新建一个类的对象的时候,我们需要将类的一些属性进行设置,这个时候我们就需要类的构造函数.在Python里面是用`__init__`来作为类的构造函数

```python
def __init__(self, [...):
```

##### 析构函数

与构造函数相对应的就是析构函数,析构函数是在销毁一个对象时调用的,具体到Python里面,当一个对象被Python的垃圾回收机制回收的时候就会调用这个析构函数.在这里我们需要注意的一点是它是在被Python的垃圾回收的时候才会调用,跟Python的内建函数`del()`是没有关系的

##### 还有点历史遗留问题

在这里还不得不提到的一点就是Python在类方面有一个遗留问题:老式类和新式类的问题,以下面的例子为例:

```python
# Old Style Class
class OldStyle:
    pass
  
# New Style Class
class NewStyle(object):
    pass
```

他们的区别就在于下面的`NewStyle`是继承了`object`,而上面这个没有.实际上这是在Python2.2版本里面为了统一`class`和`type`引入的特性,所以说以后在定义类的时候就会需要继承`object`,所有从`object`继承的类就会从`object`类里面继承了一些特性,新式类跟老式类相比是一个很大的改进,但是基于兼容性的考虑,旧式的类还是被保留了,我们在日常的开发中在Python2里的代码如果一个类没有继承别的类最好是继承`Object`类,就是说最好是定义一个新式类,不过这个问题在Python3不存在了,在Python3里面所有的类都是新式类

##### 两个内建函数

`dir()`

​		这个方法是用来返回一个对象的属性

`type()`

​		它是用来获取对象的类型

##### 示例说明

```python
class OldStyle:
  	
    def __init__(self, name, description):
        self.name = name
        self.description = description
        
class NewStyle(object):
    
    def __init__(self, name, description):
        self.name = name
        self.description = description
        
if __name__ == '__main__':
  old = OldStyle('old', 'Old style class')
  print(old)
  print(type(old))
  print(dir(old))
  print('===================')
  new = NewStyle('new', 'New style class')
  print(new)
  print(type(new))
  print(dir(new))
```

用两种不同的方式定义了两个类,分别是叫`OldStyle`的旧式类和`NewStyle`的新式类,他们的构造函数以及属性都是相同的,然后在`main`里面分别把这两个类实例化,然后分别输出了类本身,类的种类,还有类的属性.

代码运行的结果:新式类和老式类在输出这个类本身的时候,很不一样,老式类是

`<_main_.OldStyle instance at 0xssfasfasdfasf>`而新式类是叫`<_main_.NewStyle object at 0xssfasfasdfasf>`;在`type`就有更明显的区别,我们可以看到老式类的对象它是`<type ‘instance’>`instance类,而不是它自己定义的`OldStyle`类,可以看到在新式类里面这个问题不复存在,`NewStyle`这个类的所有对象都会被判断是`NewStyle`这个类;老式类的属性不较少,而新式类可以看到很多前后两个下划线的属性,他们都是从object继承过来的这些属性.

由于有这些方法的存在就让新式类会比老式类有更强大的功能.

#### 3-2 定义类的属性

首先会谈谈用Python定义类的基本方式,然后谈谈关于Python里面类的属性的访问控制,最后会用一个简单的例子介绍定义类的方法

##### 直接在类里定义

```python
class Programmer:
    sex = 'male'
```

这种定义的方式,它这个类的对象,它被对所有这个类的对象所共享,也就意味着如果在不针对这个属性做修改的话,所有的这个类的对象它这个属性都是一样的

##### 在构造函数里定义

```python
class Programmer:
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

这个是在构造对象的时候把属性的值传进去,每个不同的对象它的属性值就会不太一样

##### 访问控制

​	  在面向对象的属性里有访问控制,比如Java,它就会对一个类的属性有不同的访问控制,有`public`,`private`,但是在Python里面,Python其实是没有任何的访问控制的,而且Python也没有提供私有属性的功能,平时在实际工作中实际上是依靠一些Python的编程规范,通过命名规则来进行约束,实际上Python本身是不提供私有属性的功能.

```python
class Programmer:
    def __init__(self, name, age, weight):
        self.name = name
        self._age = age
        self.__weight = weight
```

这就是平时工作中类里面定义属性的三种方法:

`name`前面没有下划线,那么代表这个属性是可以公开访问的

`_age`在属性前面加一个下划线,那么这种定义的属性代表它是这个类的私有属性,但是如果我们想访问,依然是可以访问的,这个只是说在编程规范的约束而不是Python本身语法的约束

`__weight`还有一种定义方法就是在变量名的前面加两个下划线,这种方法实际上实现了部分的私有属性,也就是说如果想访问这个属性的话,在类里面是可以访问的,但是如果在类的对象里想直接访问是不行的,但是实际上它也不是真正的私有属性,而是Python在属性的名称上耍了一个小聪明

##### 示例说明

```python
class Programmer:
    hobby = 'Play Computer'
    
    def __init__(self, name, age, weight):
        self.name = name
        self._age = age
        self.__weight = weight
        
    def get_weight(self):
        return self.__weight
      

if __name__ == '__main__':
    programmer = Programmer('Albert', 25, 80)
    print(dir(programmer))
    print(programmer.__dict__)
    print(programmer.get_weight())
    print(programmer._Programmer__weight)
```

定义了一个类`Programmer`,在类里面直接定义了一个属性`hobby`,还有三个属性是在构造函数里定义的,分别是`name`, `_age`和`__weight`,同时在类里定义了一个方法是来获取`weight`这个属性,叫`get_weight`

`main`里面首先是把这个对象实例化,然后把它的所有的属性打印出来,然后打印它从构造函数里获得的属性(通过`__dict__`可以看到programmer对象里面的属性的键值的情况),接下来调用`get_weight`来获取`weight`属性;

![截屏2020-02-0216.28.49](/Users/gregoryshen/Desktop/截屏2020-02-0216.28.49.png)

可以看到从构造函数里构造的属性`name`和`_age`是没有变化的,但是`__weight`在前面被加了一个`_Programmer`,这样就变相的实现了一种私有属性访问,但是实际上想访问这个`__weight`仍然是可以的,只不过是把属性名称改了一下,就OK了.

####  3-3 定义类的方法

首先来谈到有两个概念:

##### 函数和方法

* 函数是直接用函数名调用的
* 方法是类的一部分

有时候我们平时说的时候会有点混用,他们实际上代表了不同的意思,函数是直接调用函数名来调用的,而方法是必须和对象结合在一起使用.也就是说,函数仅仅是一块代码来供人调用,但是方法是从属于某个类,由别的程序来调用的.这是他们很重要的一个区别: 是不是依附于一个类.

##### 类的方法也是类的属性

在Python里一切皆对象,我们可以把类里面的方法看作是一个属性,它的类型是`Method`类.我们在这里用代码举了一个很简单的例子:

```python
>>> class Test:
  	    def test(self):
      			pass
      
>>> a = Test()
>>> a.test
<bound method Test.test of <__main__.Test object at 0x7f110d219310>>
>>> a.test = '123'
>>> a.test
'123'
```

我把这里原本的方法`test`替换成了一个字符串,并且我把这个`test`方法打印了一下,可以看到是一个叫method的对象,但是在下面把test替换成一个字符串,说明方法也是一个属性

##### 方法的访问控制

因为之前谈到,它的方法可以看作是method类型的属性的话,那么它的访问控制实际上跟属性一样,也是没有.关于定义的方法,其实跟属性一样,也是平时靠自觉

* 跟属性一样,也是基本没有
* 一切靠自觉

##### 常用的方法定义

```python
class Example:
    def add(self):
        pass
      
		def _minus(self):
        pass
      
    def __multiply(self):
        pass
```

还有两个比较重要的关于方法的装饰器

##### `@classmethod`

调用的时候用类名,而不是某个对象

它跟我们之前在定义类的属性里就是那种直接在类里面定义的属性有点类似,就是说它在调用的时候是直接用类名来调用,而不是说由类生成一个对象,由对象来调用

##### `@property`

像访问属性一样调用方法

它实际上是把调用方法的样子改了一下,就像调用属性一样

##### 示例说明

```python
class Programmer:
    hobby = 'Play Computer'
    
    def __init__(self, name, age, weight):
        self.name = name
        self._age = age
        self.__weight = weight
        
    @classmethod
    def get_hobby(cls):
        return cls.hobby
      
    @property
    def get_weight(self):
        return self.__weight
      
    def self_introduction(self):
        print('My name is {}\nI am {} years old'.format(self.name, self._age))
        
        
if __name__ == '__main__':
    programmer = Programmer('Albert', 25, 80)
    print(dir(programmer))
    print(Programmer.get_hobby())
    print(programmer.get_weight)
    programmer.self_introduction()
```

 构造函数跟之前是一样的,分别是有三个属性,接下来定义了一个类方法,就是加了`@classmethod`装饰器的方法,然后定义了一个`@property`方法,到时候在调用的时候直接用对象名+`get_weight`后面不用加括号就行了.最下面是定义了一个正常情况下的属于一个类的方法.

`main`里面:首先还是把`Programmer`类实例化得到一个对象,然后把对象的属性打印一下,然后调用它的类方法,在这里可以注意到在调用类方法的时候是直接用类名调用的;然后用实例化的对象来访问`get_weight`函数,在访问方法的时候就像访问属性一样,在后面是没有加任何括号的,最后是一个正常的调用对象里面的方法的平时的一个例子

![截屏2020-02-0122.22.02](/Users/gregoryshen/Desktop/截屏2020-02-0122.22.02.png)

#### 3-4 类的继承

继承是面向对象里非常重要的一个概念,在之前介绍面向对象基础的时候也介绍过,正是因为继承使得大量的代码能复用,也是面向对象非常大的一个优势

##### 定义类的继承

首先来看看类的继承的简单的语法:

```python
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```

##### 继承的子类

继承之后,子类

* 会继承父类的属性和方法
* 也可以自己定义,覆盖父类的属性和方法,也可以添加一些方法

##### 用super()调用父类的方法

在重写父类的时候,我们有时候可能需要调用父类里的方法,Python里提供了一个`super`方法,例子如下:

```python
class A:
    def method(self, arg):
        pass
      
class B(A):
    def method(self, arg):
        super(B, self).method(arg)
```

`super`里面有两个关键字,第一个是自己的类名,然后是`self`,然后就是你想调用的相应的方法名

##### 用类名调用父类的方法

其实还有一种更原始的方法,直接用父类名称来调用,示例如下:

```python
class A:
    def method(self, arg):
        pass
      
class B(A):
    def method(self, arg):
        A.method(arg)
```

这样不太好,因为这里没有体现类的继承关系

##### 子类的判断

继承的子类有一个比较重要的特性:一个子类的对象在判断类型的时候它会被认为是自己所在的实例化的类,同时它还会被认为是它的父类.

我们在这里用到了Python的一个内建函数

* `isinstance`:用来判断类型的
* `issubclass`:判断是否是子类

##### 多继承

我们之前谈到的是Python的单继承,还有一种继承方式是多继承,Python在原生语法里是支持多继承的,多继承和单继承的区别主要在于多继承能够从好几个类里继承相应的属性和方法,但是多继承其实在平时的应用里面不算是特别的常见.

##### 示例说明

```python
class Programmer:
    hobby = 'Play Computer'
    
    def __init__(self, name, age, weight):
        self.name = name
        self._age = age
        self.__weight = weight
        
    @classmethod
    def get_hobby(cls):
        return cls.hobby
      
    @property
    def get_weight(self):
        return self.__weight
      
    def self_introduction(self):
        print('My name is {}\nI am {} years old'.format(self.name, self._age))
        

class BackendProgrammer(Programmer):
    def __init__(self, name, age, weight, language):
        super(BackendProgrammer, self).__init__(name, age, weight)
        self.language = language
        
        
if __name__ == '__main__':
    programmer = BackendProgrammer('Albert', 25, 30, 'Python')
    print(dir(programmer))
    print(programmer.__dict__)
    print(isinstance(programmer, Programmer))
```

之前定义的`Programmer`类还是跟之前一样,然后定义了一个类`BackendProgrammer`,继承了`Programmer`,可以看到把构造函数进行了修改,调用了`BackendProgrammer`父类的构造函数.因为对`BackendProgrammer`类添加了一个属性`language`,所以在调用了父类的构造函数之后,又对多出来的属性进行赋值.

然后在`main`里面把`BackendProgrammer`这个类进行实例化,先是把它的属性打印一下,然后输出这个对象在构造函数里面所赋予的这些值的属性;然后判断`programmer`的种类;最后是来判断一下这个对象判断类型的时候是不是会被认为是它的父类.

![截屏2020-02-0121.09.25](/Users/gregoryshen/Desktop/截屏2020-02-0121.09.25.png)

先来看在构造函数里构造的属性,我们可以看到有三样从父类里继承的,`name`, `_age`和`_Programmer__weight`,多出来一个就是在子类里面定义的`language`这个属性.

#### 3-5 类的多态

##### 什么是多态

​	  这个现象可以用现实生活中的一个比喻,比如说,有一个群体的人,程序员,总体上属于一个非常大的类别,一个程序员里面又可以划分为更细分的类,比如说用不同语言的,比如Java, Python,但是他们在做同一件事的时候会有不同的流程和方法,会有不同的反馈,那么具体到举的这个例子,就是说Python程序员和一个Java程序员在写代码的时候可能流程、思考的方法还有输出的东西都不太一样,这种在做同一件事情有不同的反馈和流程的情况就是面向对象里的多态.

##### 多态的要素

在多态里面有两大要素:

**<u>继承</u>**

​	  因为这些子类必须继承于共同的父类,那么它就可以从父类继承出相应的方法

<u>**重写**</u>

​	  正是因为这种方法的重写使得各个的类在做同一件事的时候呈现出了不同的结果.在Python里面跟另外的一些面向对象语言比如Java在概念上并不完全一样,因为之前也演示过,Python是可以直接把之前的父类方法替换掉,实际上不完全是重写的语法,但它的机制实现了重写的意思.

##### 示例说明

```python
class Programmer:
  	hobby = 'Play Computer'
  
  	def __init__(self, name, age, weight):
        self.name = name
        self._age = age
        self.__weight = weight
        
    @classmethod
    def get_hobby(cls):
        return cls.hobby
      
    @property
    def get_weight(self):
        return self.__weight
      
    def self_introduction(self):
        print('My name is {} \nI am {} years old\n'.format(self.name, self.age))
        
        
class BackendProgrammer(Programmer):
  
  	def __init__(self, name, age, weight, language):
      super(BackendProgrammer, self).__init__(name, age, weight)
      self.language = language
      
    def self_introduction(self):
      print('My name is {}\nMy favourite language is {}'.format(self.name, self.language))
      
      
def introduce(programmer):
    if isinstance(programmer, Programmer):
        programmer.self_introduction()

        
if __name__ == '__main__':
    programmer = Programmer('Albert', 25, 80)
    backend_programmer = BackendProgrammer('Tim', 30, 70, 'Python')
    introduce(programmer)
    introduce(backend_programmer)
```

继承`Programmer`类的叫`BackendProgrammer`,在这个类里面重写了父类的`self_introduction`方法, 把它的输出稍微做了下修改.

又定义了一个函数`introduce`:首先会判断传进来的参数是不是属于`Programmer`对象,如果判断它是`Programmer`对象,那就直接调用这个对象的`self_introduction`方法.

`main`里面就是实例化了两个类,然后分别用`introduce`来调用`self_introduction`方法.

在这里可以看到,正是因为多态的特性使得添加功能的时候会非常简单.`introduce`这个方法只要保证传入参数的类属于`Programmer`类,就可以直接调用传入参数的`self_introduction`了

![截屏2020-02-0118.12.55](/Users/gregoryshen/Desktop/截屏2020-02-0118.12.55.png)

可以看到,上面就是在`Programmer`里定义的输出结果;下面是在子类里修改的结果,这就是多态.

多态的好处:在添加功能的时候会非常简单,只要判断一下它是不是属于它的父类,就可以不管它传进来的具体是哪个子类而去调用这个方法

### 第4章 深入Python面向对象

#### 4-1 magic method

##### 魔术方法是什么

​	  Magic Method是关于Python面向对象的一整套方法,涉及到了对象的方方面面,从对象的建立,属性访问,到对运算符的支持,对一些特殊语法的支持等等.利用魔术方法我们可以以极大的自由度来定制类.

##### 魔术方法的作用

​	  给我们的类添加魔法的

##### 魔术方法长什么样

​	  具体是在方法的名称前后有两个下划线,例子比如构造函数/析构函数,它就是一个Magic method.

#### 4-2 对象的实例化

首先我们来介绍关于对象的创建和初始化这个过程.

##### 常用的类定义

首先来谈之前介绍过的平时用来定义类的过程:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
person = Person('Albert', 25)
```

一般在类里定义一个叫`__init__`的方法,作为类的构造函数,它也是我们定义类的最常用模式,我们一般会在`__init__`里做些什么:会用来对对象的属性进行设置.然后在真正实例化对象的时候往构造函数里传入相应的参数就可以了

但是一个对象实例化的过程在这里是没有完全展现出来的.它真正的过程实际上是分成了两步,

##### 对象实例化的过程

首先是要创建一个类的对象,然后再进行对象的初始化,分别对应着两个魔术方法

创建类的对象: `def __new__(cls)`

初始化对象: `def __init__(self)`

在日常情况下我们并不用去定义`__new__`,因为我们继承了父类,由父类的`__new__`方法来帮我们完成.

`__new__`是在`__init__`之前调用的,它做的事情是返回一个类的初始对象.如果有一些比较特殊的需求,可以考虑重写`__new__`方法,但是需要注意的是它是需要返回一个对象

##### 回收对象

最后来说说在销毁对象使用到的魔术方法.

Python是有垃圾回收机制的,并不需要我们手动地回收内存.当一个对象被Python的垃圾回收机制回收的时候就会调用`__del__`方法,这个方法在实际中也是很少会用到的.一般来说本身的垃圾回收机制是不需要我们进行修改的.在实际中主要是用来写`__init__`方法就好了.

##### 示例说明

这里并没有演示`__del__`这个魔术方法,原因是这个方法是由Python的回收机制来调用的,这个过程我们不可控.

```python
class Programmer:
  
		def __new__(cls, *args, **kwargs):
        print('call __new__ method')
        print(args)
        return super(Programmer, cls).__new__(cls, *args, **kwargs)
      
    def __init__(self, name, age):
        print('call __init__ method')
        self.name = name
        self.age = age
        
if __name__ == '__main__':
    programmer = Programmer('Albert', 25)
    print(programmer.__dict__)
```

在Programmer类里面定义了`__new__`和`__init__`方法,在这里面重写了`__new__`方法,在开始的时候打印了一句call,然后把传入的参数打印了一下,最后调用父类的`__new__`方法返回对象.这么做的目的是把真正的实例化对象的过程展现出来,之间的运行到底是怎样的顺序

main里面把programmer在构造函数里传入的属性打印一下(`__dict__`)

![截屏2020-01-3121.38.33](/Users/gregoryshen/Desktop/截屏2020-01-3121.38.33.png)

这就印证了构造实例的过程是首先调用`__new__`方法,用来返回一个`Programmer`对象,然后把这个Programmer对象交给`__init__`,由它来对属性进行设置,那么这就是一个完整的构造对象的过程

#### 4-3 类与运算符

有时候我们定义类需要进行一些运算符的计算,比如说比大小、加减乘除,如果没有magic method的话, 我们需要另外定义方法来完成这些内容.但是在Python里面有强大的magic method的帮助, 可以让我们的类能够使他们的运算符计算得到Python基础语法的支持,是一种非常优美的解决方案

##### 用Magic Method实现的好处

* 优雅
* 被Python的标准语法支持

##### 举个例子

在这里通过一个简单的例子说明一个对象为什么能够支持运算符

```python
>>> s = 'test'
>>> s == s
True
>>> dir(s)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__']
```

首先定义了一个字符串,然后判断这个字符串是否与它自身相等,最后打印了一下字符串对象的属性

需要重点关注`__eq__`,正是字符串对象里有`__eq__`这个方法,使得它这个对象能够判断与另外一个对象是否相等.同理,如果想让你的类支持其他的运算符,也会有相应的魔术方法的支持

把Python里主要的运算符分为三类,第一类是

##### 比较运算符

`__cmp__(self, other)`

包含了两个对象相比较的所有情况,比如说大小,大于小于等于,大于等于、小于等于这种情况

`__eq__(self, other)`

处理等于的情况,就是一个对象与另外一个对象判断它是否等于

`__lt__(self, other)`

小于

`__gt__(self, other)`

大于

##### 数字运算符

`__add__(self, other)`

`__sub__(self, other)`

`__mul__(self, other)`

`__div__(self, other)`

典型的列出了加减乘除四种运算,在类里面把相应的魔术方法定义好之后,类的对象就可以进行加减乘除的运算

##### 逻辑运算符

`__or__(self, other)`

`__and__(self, other)`

比如在判断语句里需要判断`or`或者`and`,这个也是可以通过魔术方法来支持的

##### 示例说明

```python
class Programmer:
  
    def __init__(self, name, age):
        self.name = name
        if isinstance(age, int):
            self.age = age
        else:
            raise Exception('age must be int')
            
    def __eq__(self, other):
        if isinstance(other, Programmer):
            if self.age == other.age:
                return True
            else:
                return False
        else:
          raise Exception('The type of object must be Programmer')
          
    def __add__(self, other):
        if isinstance(other, Programmer):
            return self.age + other.age
        else:
            raise Exception('The type of object must be Programmer')
            

if __name__ == '__main__':
    p1 = Programmer('Albert', 25)
    p2 = Programmer('Bill', 30)
    print(p1 == p2)
    print(p1 + p2)
            
```

在类里定义了两个运算符有关的魔术方法,一个是`__eq__`,就是判断两个对象是否相等;一个是`__add__`,就是进行加法运算.

可以看到在`__eq__`里面是如何判断两个对象相等的:首先要判断传进来的`other`这个对象是不是也是`Programmer`类型的对象,然后把它的`age`属性进行比较,如果他们俩相等就会返回`True`,否则返回`False`

`__add__`方法也类似,首先是判断与本身这个对象相加的另外一个对象是不是`Programmer`对象,然后如果是`Progrmmer`类型的,把他们两个的`age`属性相加,返回

在`main`里面定义了两个`Progrmmer`对象,分别设置了不同的`age`属性.首先判断这两个对象是否相等,依据上面的定义我是通过`age`属性来判断两个对象是否相等的,所以他们两个的`age`属性不一样,那么我预期的他们俩判断是否相等的结果:他们俩应该是不相等的.然后下面打印了`p1 + p2`,也是根据上面的定义,是返回他们两个的`age`属性之和,在这里`p1 + p2`结果应该是25+30=55

#### 4-4 类的展现

有时候定义了一个类并且由类实例化一个对象后,我们可以用`print`方法把它打出来,是因为我们在`print`的过程中实际上把对象转换成了一个字符串.在Python的内建方法中有三个方法把一个对象转换成字符串,分别是:`str()`,`repr()`和`unicode()`,这三个方法分别对应了三个魔术方法,也就是说一个对象如果能够被相应的方法转换成字符串的话,那么它在类里面肯定是自己定义了或者是从父类继承了相应的魔术方法:

`__str__`

`__repr__`

`__unicode__`

在这里可以看到这三种方法:`__str__`和`__unicode__`在Python里是两种不同的对象;`__str__`和`__repr__`的区别是在于它的目的是把对象转换成适合机器看的字符串,而`__str__`是把对象转换成适合人看的字符串

> 怎么理解`__str__`和`__repr__`的区别?

​		在Python里有个内置的方法`eval()`,它的作用是把一段字符串作为Python代码来运行,一个对象由`repr()`转换成的字符串是可以由`eval()`这个函数直接作为Python代码运行的,而`str()`转换出来的字符串就不行

##### 展现对象属性

​	  在Python里有个内建方法`dir()`:查看对象属性.与之对应的对象里有个叫`__dir__`这个魔术方法来控制调用`dir()`这个函数的结果.有时候可能有一些比较特殊的需求,不想把所有的属性全都暴露出来,那么我们就可以自己来定义`__dir__`这个魔术方法

##### 示例说明

```python
class Programmer:
  
  	def __init__(self, name, age):
      self.name = name
      if isinstance(age, int):
        	self.age = age
      else:
        	raise Exception("age must be int")
          
    def __str__(self):
        return '%s is %s years old' % (self.name, self.age)
      
    def __dir__(self):
        return self.__dict__.keys()
      
      
if __name__ == '__main__':
    p = Programmer('Albert', 25)
    print(p)
    print(dir(p))
```

分别定义了两个和展现有关的魔术方法:`__str__`和`__dir__`, 首先把这两个方法注释掉,看看实例化`Programmer`这个对象后把它直接转换成字符串和直接返回它的属性会得出什么样的结果.

![截屏2020-01-3019.00.49](/Users/gregoryshen/Desktop/截屏2020-01-3019.00.49.png)

那么可以看到,首先,我们把`Programmer`这个对象直接转换成字符串会得到这样一串东西,而`dir()`就会把所有的属性都打印出来.

然后把定义的两个方法去掉注释,来看看我把它转换成字符串的时候是怎样定义的:

```python
def __str__(self):
    return "%s is %s years old" % (self.name, self.age)
```

实际上是返回了一个字符串,某某is 多少 years old

```python
def __dir__(self):
    return self.__dict__.keys()
```

而在`__dir__`里面,只把它在构造函数里定义的属性的键返回

再来看一下运行结果:

![截屏2020-01-3019.17.24](/Users/gregoryshen/Desktop/截屏2020-01-3019.17.24.png)

在这里可以看到结果立马就不一样了,变成了在类里面定义的魔术方法输出的东西.

Python的内建函数大部分都是有相应的魔术方法支持的,也就是说如果你想让你的类的对象能够使用Python里面的很多内建方法,那么可以定义相应的魔术方法使得类的对象支持这些函数的调用

#### 4-5 类的属性控制

在这一节里面介绍和类的属性有关的魔术方法

在前面介绍到关于类的属性的时候,它的访问控制的问题,Python的类本身并没有真正的访问控制的机制,如果在类里定义了用两个下划线开头的属性,它在处理的时候仅仅是把属性改了一个名字,并不会阻止你去访问它,但是通过magic method,我们可以给类的属性添加我们想要的访问控制.

现在就来说说跟对象属性有关的魔术方法,首先是设置对象属性:

##### 设置对象属性

```python
__setattr__(self, name, value)
```

如果我们在给一个对象设置属性的时候,它实际上会调用到这个类的`__setattr__`方法,这个方法在平时是用不着去定义的因为实际上会调用我们从父类继承的方法.

##### 需要注意的

不过在使用`__setattr__`包括其他的跟属性有关的魔术方法的时候,特别需要注意的一点,就是一旦让你的代码写出了这种==无限递归==的,有这种可能性, 在这里列出两个例子,就是分别两种定义`__setattr__`的两种写法:

```python
def __setattr__(self, name, value):
    setattr(self, name, value)
    
def __setattr__(self, name, value):
    self.__dict__[name] = value
```

上面使用Python的内建函数`setattr()`这个方法,下面使用Python的`__dict__`属性,它是存放在各个函数里设置的键值对的一个地方

这两种写法上面这种的是错误的,下面这种的是正确的,因为我们在设置属性的时候如果在`__setattr__`又调用了Python内建的`setattr`,那么它实际上会导致它在给self对象设置属性的时候又调回它自己,导致无限的循环递归,Python里面对递归是有数量限制的,默认是1000次,超过1000次后程序就会报错;如果按下面的方式来设置对象的属性就不会导致无限循环递归的状况

##### 查询对象属性

```python
__getattr__(self, name)
__getattribute__(self, name)
```

这两个魔术方法的作用稍有不同,`__getattr__`是在访问这个属性在默认情况下没有被查询到的情况下那么就会调用`__getattr__`;而`__getattribute__`是在每次访问属性的时候都一定会调用到,这就是二者的区别

需要注意的是,在调用`__getattribute__`的时候,它更容易引起之前说的那种无限递归的状况,所以在使用的时候要特别注意

##### 删除对象属性

也就是在用Python内建的`del()`来删除某个对象属性的时候调用的,跟之前的设置比较类似:

```python
__delattr__(self, name)
```

##### 示例说明

```python
class Programmer:
  
  	def __init__(self, name, age):
        self.name = name
        self.age = age
        
    def __getattribute__(self, name):
        # return getattr(self, name)
        # return self.__dict__[name]
        return super(Programmer, self).__getattribute__(name)
      
    def __setattr__(self, name, value):
        # setattr(self, name, value)
        self.__dict__[name] = value
        
        
if __name__ == '__main__':
    p = Programmer('Albert', 25)
    print(p.name)
```

分别对属性的设置和获取定义魔术方法,在设置属性的时候是用的`__setattr__`,在获取属性的时候是用的`__getattribute__`,也就是说在每次获取属性的时候都会调用它.首先来试试设置属性, 先采用第一种错误的方法: `setattr(self, name, value)`

 ![截屏2020-01-3022.05.58](/Users/gregoryshen/Desktop/截屏2020-01-3022.05.58.png)

这里就引发了之前说的无限递归的问题,

改回成正确的写法: `self.__dict__[key] = value`

![截屏2020-01-3022.09.46](/Users/gregoryshen/Desktop/截屏2020-01-3022.09.46.png)

这个代码就能够正常运行.

接下来试下更容易引起无限递归的`__getattribute__`方法:

首先来看`return getattr(self, key)`

![截屏2020-01-3022.12.56](/Users/gregoryshen/Desktop/截屏2020-01-3022.12.56.png)

可以看到又一次引起无限递归

下面尝试`return self.__dict__[key]`

![截屏2020-01-3022.15.16](/Users/gregoryshen/Desktop/截屏2020-01-3022.15.16.png)

使用字典来获取属性依然引起了无限递归,这说明==在`__dict__`里面获取值的时候它也会调用到`__getattribute__`这个方法==

最后使用正确的也是推荐的写法:最好调用父类的`__getattribute__`方法,这样才能不出现无限递归的情况

![截屏2020-01-3022.19.27](/Users/gregoryshen/Desktop/截屏2020-01-3022.19.27.png)

### 第5章 课程总结

#### 5-1 课程总结

##### 面向对象理论

* 类和对象

  ​	  首先是就是面向对象的理论,在这里介绍了类和对象,类是对一类事物的抽象和总结,对象是类的一个实体

* 属性和方法

  ​	  就是在类里面有一些属性用来存放一些数据,有方法存放类的一些功能,并且方法具有封装性

* 继承

  ​	  面向对象里面继承是可以让子类从父类全盘继承它的属性和方法,并且在子类里面可以根据自己的需要从父类继承的属性和方法进行一些改变.

##### Python面向对象基础

* 定义类

  ​	  主要要注意的是在里面用到了`class`关键字

* 定义属性和方法

  ​	  定义属性一般是在定义类的构造函数里面写的,定义方法也跟构造函数差不太多 

* 继承

  ​	  Python里面的类的继承它是把它放在类名之后的括号里面的.在这里需要注意的是,在Python里面定义类如果是没有别的类继承的话最好让他继承`object`,因为这也是Python的一个遗留问题(继承`object`类会被算作新式类,新式类有很多新的功能)

##### Magic Method

* 构造对象

  ​	  最典型的就是最常使用的构造函数.在Python实例化对象里面最开始的一步实际上是创建一个类的对象,用的魔术方法叫`__new__`;当一个对象被垃圾回收的时候调用的叫`__del__`

* 运算符

  ​	  包含各种算数运算符、逻辑运算符,每种运算符都有一个魔术方法与其相对应

* 类的展现

  ​	  比如将类转换成字符串,转换成Unicode,如果你想让你的类支持这种转换的话,就需要在类里面定义相应的魔术方法,比如转换成字符串,需要在类里面定义`__str__`,转换成Unicode,就需要在类里面定义`__unicode__`这个方法.

* 类的属性访问

  ​	  主要包括设置属性、查询属性和删除属性.重点介绍了在使用类的属性访问的魔术方法里面需要注意的一点就是:不要在代码里使得它最终有无限递归的错误.





























