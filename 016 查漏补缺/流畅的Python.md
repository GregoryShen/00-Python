## 第一部分 序幕

### 第 1 章 Python 数据类型

1.4 为什么 len 不是普通方法

## 第二部分 数据结构

### 第 2 章 序列构成的数组

你们可能注意到了，之前提到的几个操作可以无差别地应用于文本、列表和表格上。我们把文本、列表和表格叫做数据火车…FOR 命令通常能作用于数据火车上。

ABC 语言是一个致力于为初学者设计编程环境的长达10年的研究项目，其中很多点子在现在看来都很有 Python 风格：序列的范型操作、内置的元组和映射类型、用缩进来架构的源码、无需变量声明的强类型等等。Python 对开发者如此友好，根源就在这里。

Python 也从 ABC 那里继承了用统一的风格去处理序列数据这一特点。不管是哪种数据结构，字符串、列表、字节序列、数组、XML 元素，抑或是数据库查询结果，它们都共用一套丰富的操作：迭代、切片、排序还有拼接。

深入理解 Python 中不同序列类型，不但能让我们避免重新发明轮子，它们的 API 还能帮助我们把我们自己定义的 API 设计的跟原生序列一样，或者是跟未来可能出现的序列类型保持兼容。

本章讨论的内容几乎可以应用到所有的序列类型上，从我们熟悉的 list, 到 Python3 中特有的 str 和 bytes。还会特别提到跟列表、元组、数组以及队列有关的话题。但是 Unicode 字符串和字节序列的内容被放在了第4章。另外这里讨论的数据结构都是 Python 中现成可用的，如果你想知道怎样创建自己的序列类型要等到第10章。

#### 2.1 内置序列类型概览



#### 2.2 列表推导和生成器表达式



##### 2.2.1 列表推导的可读性



##### 2.2.2 列表推导同 filter 和 map 的比较



##### 2.2.3 笛卡尔积



##### 2.2.4 生成器表达式



#### 2.3 元组不仅仅是不可变的列表

2.3.1 元组和激素

2.3.2 元组拆包

2.3.3 嵌套元组拆包

2.3.4 具名元组

2.3.5 作为不可变列表的元组

2.4 切片

2.4.1 为什么切片和区间会忽略最后一个元素

2.4.2 对对象进行切片

2.4.3 多位切片和省略

2.4.4 给切片复制

2.5 对序列使用+和*

2.6 序列的增量赋值

2.7 list.sort 方法和内置函数 sorted

2.8 用 bisect 来管理已排序的序列

2.8.1 用 bisect 来搜索

2.8.2 用 bisect.insort 插入新元素

2.9 当列表不是首选时

2.9.1 数组

2.9.2 内存时图

2.9.3 NumPy 和 SciPy

2.9.4 双向队列和其他形式的队列

2.10 本章小结

2.11 延伸阅读

### 第 3 章 字典和集合

### 第 4 章 文本和字节序列



## 第三部分 把函数视作对象

### 第 5 章 一等函数

> 不管别人怎么说或怎么想，我从未觉得 Python 受到来自函数式语言的太多影响。我非常熟悉命令式语言[^1]，如 C 和 Algol 68，虽然我把函数定为一等对象，但是我并不把 Python 当做函数式编程语言。
>
> ​	— 摘录自 Guido 的 The History of Python 博客，“[Origins of Python’s Functional Features](http://python-history.blogspot.jp/2009/04/origins-of-pythons-functional-features.html)”

在 Python 中，函数是一等对象。编程语言理论家把“一等对象”定义为满足下述条件的程序实体：

* 在运行时创建
* 能赋值给变量或数据结构中的元素
* 能作为参数传递给函数
* 能作为函数的返回结果

在 Python 中，整数、字符串和字典都是一等对象—没什么特别的。如果在 Python 之前，你使用的语言并未把函数当做一等公民，那么本章以及第三部分余下的内容将重点讨论把函数作为对象的影响和实际应用。

> 人们经常将“把函数视作一等对象”简称为“一等函数”。这样说并不完美，似乎表明这是函数中的特殊群体。在 Python 中，所有函数都是一等对象。

#### 5.1 把函数视作对象

示例 5-1 中的控制台会话表明，Python 函数是对象。这里我们创建了一个函数，然后调用它，读取它的`__doc__`属性，并且确认函数对象本身是 function 类的实例。



#### 5.2 高阶函数 map、filter和 reduce 的现代替代品

接受函数为参数，或者把函数作为结果返回的函数是高阶函数（higher-order function）。map 函数就是一例，如示例 5-2 所示。此外，内置函数 sorted 也是：可选的 key 参数用于提供一个函数，它会应用到各个元素上进行排序，参见 2.7 节。

例如，若想根据单词的长度排序，只需把 len 函数传给 key 参数，如示例 5-3 所示。



##### map、filter 和 reduce 的现代替代品

函数式语言通常会提供 map、filter 和 reduce 三个高阶函数（有时使用不同的名称）。在 Python 3 中，map 和 filter 还是内置函数，但是由于引入了列表推导式和生成器表达式，它们变得没那么重要了。列表推导式和生成器表达式具有 map 和 filter 两个函数的功能，而且更易于阅读，如示例 5-5 所示。

示例 5-5  计算阶乘列表： map 和 filter 与列表推导比较

```python
>>> list(map(fact, range(6)))
[1, 1, 2, 6, 24, 120]
>>> [fact(n) for n in range(6)]
[1, 1, 2, 6, 24, 120]
>>> list(map(factorial, filter(lambda n: n % 2, range(6))))
[1, 6, 120]
>>> [factorial(n) for n in range(6) if n % 2]
[1, 6, 120]
>>> [factorial(n) for n in range(6) if n % 2==0]
[1, 2, 24]
>>> [factorial(n) for n in range(6) if n % 2==1]
[1, 6, 120]
```

在 Python 3 中，map 和 filter 返回生成器（一种迭代器），因此现在他们的直接替代品是生成器表达式（在 Python 2 中，这两个函数返回列表，因此最接近的替代品是列表推导）。

在 Python 2 中，reduce 是内置函数，但是在 Python 3 中放到了 functools 模块里了。这个函数最常用于求和，自 2003 年发布的 Python 2.3 开始，最好使用内置的 sum 函数。在可读性和性能方面，这是一项重大改善。

示例 5-6 使用 reduce 和 sum 计算 0~99 之和

```python
In [14]: from functools import reduce
In [15]: from operator import add
In [16]: reduce(add, range(100))
Out[16]: 4950
In [17]: sum(range(100))
Out[17]: 4950
```

sum 和 reduce 的通用思想是把某个操作连续应用到序列的元素上，累计之前的结果，把一系列值归约成一个值。

all 和 any 也是内置的guiyue

#### 5.3 匿名函数



#### 5.4 可调用对象

5.5 用户定义的可调用类型

5.6 函数内省

5.7 从定位参数到仅限关键字参数

5.8 获取关于参数的信息

5.9 函数注解

5.10 支持函数式编程的包

5.10.1 operator 模块

5.10.2 使用 functools.partial 冻结参数

5.11 本章小结

5.12 延伸阅读

### 第 6 章 使用一等函数实现设计模式



### 第 7 章 函数装饰器和闭包

7.1 装饰器基础知识

7.2 Python 何时执行装饰器

7.3 使用装饰器改进“策略”模式

7.4 变量作用域规则

7.5 闭包

7.6 nonlocal 声明

7.7 实现一个简单的装饰器

7.8 标准库中的装饰器

7.8.1 使用 functools.lru_cache 做备忘

7.8.2 单分派泛函数

7.9 叠放装饰器

7.10 参数化装饰器

7.10.1 一个参数化的注册装饰器

7.10.2 参数化 clock 装饰器

7.11 本章小结

7.12 延伸阅读

## 第四部分 面向对象惯用法

### 第 8 章 对象引用、可变性和垃圾回收

8.1 变量不是盒子



### 第 9 章 符合 Python 风格的对象



### 第 10 章 序列的修改、散列和切片

















