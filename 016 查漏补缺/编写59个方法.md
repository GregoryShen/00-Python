## 第1章 用 Pythonic 方式来思考

### 第01条：确认自己所用的 Python 版本

### 第02条：遵循 PEP8 指南

### 第03条：了解 bytes、str 与 unicode 的区别

### 第04条：用辅助函数来取代复杂的表达式

### 第05条：了解切割序列的办法

### 第06条：在单次切片操作内，不要同时指定 start、end 和 stride

### 第07条：用列表推导式来取代 map 和 filter

Python 提供了一种精练的写法，可以根据一份列表来制作另外一份。这种表达式称为列表推导。例如，要用列表中每个元素的平方值构建另一份列表。如果采用列表推导来实现，那就是同时指定制作新列表时所要迭代的输入序列，以及计算新列表中每个元素的值时所用的表达式。

```python
>>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> squares = [x**2 for x in a]
>>> print(squares)
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

除非是调用只有一个参数的函数，否则，对于简单的情况来说，列表推导式要比内置的 map 函数更清晰。如果使用 map，那就要创建 lambda 函数，以便计算新列表中各个元素的值，这会使代码看起来有些乱。

```python
>>> squares = map(lambda x: x ** 2, a)
>>> squares
<map object at 0x102dd5fd0>
```

列表推导则不像 map 那么复杂，它可以直接过滤原列表中的元素，使得生成的新列表不会包含对应的计算结果。例如，在计算平方值时，我们只想计算那些可以为2所整除的数。如果采用列表推导来做，那么只需在循环后面添加条件表达式即可：

```python
>>> even_squares = [x**2 for x in a if x % 2 == 0]
>>> print(even_squares)
[4, 16, 36, 64, 100]
```

把内置的 filter 和 map 结合起来，也能达成同样的效果，但是代码会写的非常难懂

```python
```

字典（dict）与集（set）也有和列表类似的推导机制。编写算法时，可以通过这些推导机制来创建衍生的数据结构

```python
```

#### 要点

* 列表推导式要比内置的 map 和 filter 函数清晰，因为它无需额外编写 lambda 表达式
* 列表推导式可以跳过输入列表中的某些元素，如果改用 map 来做，那就必须辅以 filter 方能实现
* 字典与集合也支持推导表达式。

## 第2章 函数

### 第15条：了解如何在闭包里使用外围作用域中的变量

### 第16条：考虑用生成器来改写直接返回列表的函数

### 第17条：在参数上面迭代时，要多加小心

## 第3章 类与继承



### 第 23 条：简单的接口应该接受函数，而不是类的实例

Python 有许多内置的 API，都允许调用者传入参数，以定制其行为。API 在执行的时候，会通过这些 hook 函数，回调函数内的代码。例如，list 类型的 sort 方法接受可选的 key 参数，用以指定每个索引位置上的值之间应该如何排序。下面这段代码，用 lambda 表达水充当 key hook，以便根据每个名字的长度来排序：

```python
>>> names = ['Socrates', 'Archimedes', 'Plato', 'Aristotle']
>>> names.sort(key=lambda x: len(x))
>>> print(names)
['Plato', 'Socrates', 'Aristotle', 'Archimedes']
```

其他编程语言可能会用抽象类来定义挂钩。然而在 Python 中，很多挂钩只是无状态的函数，这些函数有明确的参数及返回值。用函数做挂钩上比较合适的，因为他们很容易就能描述出这个挂钩的功能，而且比定义一个类要简单。Python 中的函数之所以能充当挂钩原因就在于它是一级对象，也就是说，函数与方法可以像语言中的其他值那样传递和引用。

。。。中间好大一段例子。。。

### 第24条：以 @classmethod 形式的多态去通用地构建对象

 在 Python 中，不仅对象支持多态，类也支持多态。那么，类的多态是什么意思？它又有什么样的好处？

多态，使得继承体系中的多个类都能以各自所独有的方式来实现某个方法。这些类，都满足相同的接口或继承自相同的抽象类，但却有着各自不同的功能。

例如，为了实现一套 MapReduce 流程，我们需要定义公共基类来表示输入的数据。下面这段代码就定义了这样的基类，它的 read 方法必须由子类来实现：

```python
class InputData:
    def read(self):
        raise NotImplementedError
```

现在编写 InputData 类的具体子类，以便从磁盘文件里读取数据。

```python
class PathInputData(InputData):
    def __init__(self, path):
        super().__init__()
        self.path = path
        
    def read(self):
        return open(self.path).read()
```

我们可能需要很多像 PathInputData 这样的类来充当 InputData 的子类，每个子类都需要实现标准接口中的 read 方法，并以字节的形式返回待处理的数据。其他的 InputData 子类可能会通过网络读取并解压缩数据。

此外，我们还需要为 MapReduce 工作线程定义一套类似的抽象接口，以便用标准的方式来处理输入的数据。

```python
class Worker:
    def __init__(self, input_data):
        self.input_data = input_data
        self.result = None
        
    def map(self):
        raise NotImplementedError
        
    def reduce(self, other):
        raise NotImplementedError
```

下面定义具体的 Worker 子类，以实现我们想要的 MapReduce 功能。本例所实现的功能，是一个简单的换行符计数器。

```python
class LineCountWorker(Worker):
    def map(self):
        data = self.input_data.read()
        self.result = data.count('\n')
        
    def reduce(self, other):
        self.result += other.result
```



要点

* 在 Python 程序中，每个类只能有一个构造器，也就是`__init__`方法
* 通过`@classmethod`机制，可以用一种与构造器相仿的方式来构造类的对象
* 通过类方法多态机制，我们能够以更加通用的方式来构建并拼接具体的子类。

### 第25条：用 super 初始化父类



### 第26条：只在使用 Mix-in 组件制作工具类时进行多重继承





















