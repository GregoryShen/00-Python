# [图解Python中深浅copy](https://blog.csdn.net/mall_lucy/article/details/104531218)

## 赋值运算

```python
l1 = [1, 2, 3, [22, 33]]
l2 = l1
l1.append(666)

print(l1)  # [1, 2, 3, [22, 33], 666]
print(l2)  # [1, 2, 3, [22, 33], 666]
```

`l2 = l1` 是一个指向，是赋值，和深浅copy无关

## 浅copy

==列表是一个一个的槽位，每个槽位存储的是该对象的内存地址==

```python
# 例1：给大列表添加元素
l1 = [1, 2, 3, [22, 33]]
l2 = l1.copy()
# 或者用下面这种方式，也是浅copy
import copy
l2 = copy.copy(l1)

l1.append(666)
print(l1)	# [1, 2, 3, [22, 33], 666]
print(l2)	# [1, 2, 3, [22, 33]]


# 例2：给小列表添加元素
l1 = [1, 2, 3, [22, 33]]
l2 = l1.copy()
l1[-1].append(666)

print(l1)	# [1, 2, 3, [22, 33, 666]]
print(l2)	# [1, 2, 3, [22, 33, 666]]


# 例3：将l1列表中第一个元素改为6
l1 = [1, 2, 3, [22, 33]]
l2 = l1.copy()
l1[0] = 6

print(l1)	# [6, 2, 3, [22, 33]]
print(l2)	# [1, 2, 3, [22, 33]]
```

总结：

浅copy：会在内存中新开辟一个空间，存放这个copy的列表，但是列表里面的内容还是沿用之前对象的内存地址。

注意： 切片中，如果是全切，属于浅copy。

> 注： 浅copy这块，就是复制了一份原来的内存地址，复制的时候是什么样子，复制出来就是什么样子（样子是指内存地址）。所以对于原列表进行增加元素的操作的时候，自然不会有这个；但正常来说，对原列表进行修改操作，这个应该是可以直接反应到新复制的列表中，但是这里又有个例外，就是取决于被修改的元素是可变数据类型还是不可变数据类型，如果是像例题中的int，是不可变类型，所以修改之后，相当于原列表的内存地址也有变化了，所以这个变化是不会反应到新列表上的。

## 深copy

```python
import copy
l1 = [1, 2, 3, [22, 33]]
l2 = copy.deepcopy(l1)
l1.append(666)
print(l1)	# [1, 2, 3, [22, 33], 666]
print(l2)	# [1, 2, 3, [22, 33]]
```

> 所谓深拷贝就是真正复制了一份每个槽位的内容，那根据上例的话，l2复制了l1的四个元素，每个元素都占有一个新的内存地址，现在给l1新加一个元素，那这个元素自然也不会自动新复制一份到l2了。

而且目前python对<u>深拷贝还做了一个优化</u>：==将可变数据类型在内存中重新创建一份，而不可变数据类型则沿用之前的。==





























