# 数据类型和编码相关问题

## [java基础类型中的java基础类型中的char和byte的辨析及Unicode编码和UTF-8的区别](https://www.cnblogs.com/lingyejun/p/9743788.html)

### `char`和`byte`的对比

> byte

byte字节,数据存储容量1byte, byte 作为基本数据类型表示的也是一个存储范围上的概念, 有别于int/long 等专门存数字的类型, 这种类型的大小就是1 byte,而int 是4byte.

存数字的话就是1byte=8位, 2^8=256即-128~127.字符的话包括字母和汉字, 一个字母是1byte, 一个汉字是2byte.也就是可以用byte变量去存储一个英文字符,但是却存不下一个中文汉字,因为一个汉字占2byte.

总结,byte 是Java 中的一个基本数据类型,这个数据类型的长度是1byte,此byte就是彼byte,既是基本数据类型也是存储空间的基本计量单位,

> char

`char`是Java中的保留字,与别的语言不同的是,char 在Java 中是16位的,因为Java 用的是Unicode. 不过8位的ascii码包含在Unicode 中, 是从0~127的.

Java 中使用Unicode的原因是,Java的applet允许全世界范围内运行,那就需要一种可以表述人类所有语言的字符编码, Unicode.

`char`本质上是一个固定占用两个字节的无符号正整数,这个正整数对应于Unicode编号,用于表示那个Unicode 编号对应的字符.

由于固定占用两个字节,char 只能表示Unicode 编号在65536以内的字符,而不能表示超出范围的字符.

### Unicode 和 UTF-8 的对比

> Unicode

需要注意的是, Unicode 只是一个符号集, 它只规定了符号的二进制代码,却没有规定这个二进制代码该如何存储.

比如,汉字“严”的Unicode 是十六进制数4E25, 转换成二进制数足足有15位, 也就是说这个符号的表示至少需要2个字节.表示其他更大的符号,可能需要3个字节或者4个字节,甚至更多.

这里就有两个严重的问题,第一个问题是,如何才能区别Unicode 和ASCII? 计算机怎么知道三个字节表示一个符号,而不是分别表示3个符号呢? 第二个问题是,我们已经知道,英文字母只用一个字节表示就够了,如果Unicode 统一规定,每个符号用3个或4个字节表示, 那么每个英文字母前都必然有2到3个字节都是0,这对于存储来说是极大的浪费,文本文件的大小会因此大出两三倍,这是无法接受的,他们造成的结果是:

1) 出现了Unicode 的多种存储方式,也就是说有许多种不同的二进制格式可以用来表示Unicode

2) Unicode 在很长一段时间内无法推广, 直到互联网的出现

> UTF-8

互联网的普及,强烈要求出现一种统一的编码方式, UTF-8就是互联网上使用最广的一种Unicode 实现方式. 其他实现方式还包括UTF-16(字符用两个字节或四个字节表示)和UTF-32(字符用4个字节表示). UTF-8是Unicode 的实现方式之一

utf-8是一个变长编码标准,可以用1~4个字节表示一个字符, 而中文占3个字节,ascii 字符占1个字节

> 为什么我们在Java里面可以用一个char 来表示一个中文呢?

因为Java 是以Unicode 作为编码方式的. Unicode 是一个定长的编码标准, 每个字符都是2个字节,也就是1个 char类型的空间. 在编译的时候会把utf-8的中文字符转换成对应的Unicode 来进行传输运算

```java
import java.io.UnsupportedEncodingException;

public class ChineseCharCode {
  
    public static void main(String[] args) {
        String str = '中';
        char c = '中';
        // Java 使用Unicode编码,一个字符占两个字节
        System.out.println("char字符 中 二进制"+Integer.toBinaryString(c));
        try {
            // utf-8是Unicode 的实现方式之一
            System.out.println(str.getBytes('UTF-8').length);
            // utf-16也是Unicode 的实现方式之一, 但使用较少
            System.out.println(str.getBytes("UTF-16").length);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }
}
```

























